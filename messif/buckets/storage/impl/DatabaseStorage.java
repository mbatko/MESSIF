/*
 *  MemoryStorage
 * 
 */

package messif.buckets.storage.impl;

import java.io.IOException;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLRecoverableException;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Properties;
import messif.buckets.BucketStorageException;
import messif.buckets.StorageFailureException;
import messif.buckets.index.IndexComparator;
import messif.buckets.index.LocalAbstractObjectOrder;
import messif.buckets.index.impl.AbstractSearch;
import messif.buckets.storage.IntAddress;
import messif.buckets.storage.IntStorageIndexed;
import messif.buckets.storage.IntStorageSearch;
import messif.buckets.storage.InvalidAddressException;
import messif.objects.LocalAbstractObject;
import messif.objects.keys.AbstractObjectKey;
import messif.objects.nio.BinarySerializator;
import messif.objects.nio.BufferInputStream;
import messif.utility.Convert;

/**
 * Database-based storage.
 * The objects in this storage are stored in a relational database that
 * is accessed via JDBC.
 *
 * <p>
 * A database table that will hold the stored data must be created.
 * The primary key of the table must be integer compatible and
 * must be automatically generated by the database. The data column
 * types must match the given column convertors.
 * </p>
 * 
 * @param <T> the class of objects stored in this storage
 * @author xbatko
 */
public class DatabaseStorage<T> implements IntStorageIndexed<T>, Serializable {
    /** class serial id for serialization */
    private static final long serialVersionUID = 1L;

    //****************** Column convertor interface ******************//

    /**
     * Provides a conversion between database column data and object instances.
     *
     * @param <T> the type of the instance that is stored/read from the database column
     */
    public static interface ColumnConvertor<T> extends Serializable {
        /**
         * Returns a value that can be stored in a database column for the given instance.
         * @param instance the object instance from which to create a database value
         * @return a database value
         * @throws BucketStorageException if the value cannot be converted
         */
        public Object convertToColumnValue(T instance) throws BucketStorageException;

        /**
         * Returns an instance of object from the database column value.
         * A value created by previous columns is provided in {@code value}, which can
         * be either replaced by a new value, modified by this method or left intact.
         *
         * @param value the instance created by previous column convertors
         * @param column the value of the column to convert
         * @return an instance created from the column value
         * @throws BucketStorageException if the value cannot be converted
         */
        public T convertFromColumnValue(T value, Object column) throws BucketStorageException;

        /**
         * Returns <tt>true</tt> if the instance created by this convertor is compatible
         * with the given index comparator.
         * @param indexComparator the index comparator that is checked for compatibility
         * @return <tt>true</tt> if this column convertor works with compatible instances
         */
        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator);
    }


    //****************** Constants ******************//

    /** Number of miliseconds to sleep when an SQL command fail before another one is tried */
    private static final int connectionRetryTime = 500;


    //****************** Attributes ******************//

    /** Class of objects that the this storage works with */
    private final Class<? extends T> storedObjectsClass;
    /** Database connection URL */
    private final String dbConnUrl;
    /** Properties with database connection info */
    private final Properties dbConnInfo;
    /** Connection to database (according to {@link #dbConnUrl}) */
    private transient Connection dbConnection;
    /** List of column convertors */
    private final ColumnConvertor<T>[] columnConvertors;
    /** List of additional column names (same size as columnConvertors) */
    private final String[] columnNames;
    /** Number of objects SQL command */
    private final String sizeSQL;
    /** Cached prepared statement for size SQL */
    private transient PreparedStatement sizeStatement;
    /** Insert object SQL command */
    private final String insertSQL;
    /** Cached prepared statement for insert SQL */
    private transient PreparedStatement insertStatement;
    /** Delete a single object (by primary key) SQL command */
    private final String deleteSQL;
    /** Cached prepared statement for delete SQL */
    private transient PreparedStatement deleteStatement;
    /** Delete all data SQL command */
    private final String deleteAllSQL;
    /** Read single object (by primary key) SQL command */
    private final String readSQL;
    /** Cached prepared statement for read SQL */
    private transient PreparedStatement readStatement;
    /** Read single object (by data) SQL command */
    private final String readByDataSQL;
    /** Cached prepared statement for readByData SQL */
    private transient PreparedStatement readByDataStatement;
    /** Select all data SQL command */
    private final String selectSQL;


    //****************** Constructor ******************//

    /**
     * Constructs an empty database storage.
     * Note that the connection is established when the first manipulation-method is called.
     *
     * @param storedObjectsClass the class of objects that the storage will work with
     * @param dbConnUrl the database connection URL (e.g. "jdbc:mysql://localhost/somedb")
     * @param dbConnInfo additional parameters of the connection (e.g. "user" and "password")
     * @param tableName the name of the table in the database
     * @param primaryKeyColumn the name of the column that is the primary key of the table
     * @param columnNames the names of columns where the data are stored
     * @param columnConvertors the convertors that convert between the storage instances and database column;
     *          there must be one convertor for every data column name from {@code columnNames}
     * @throws IllegalArgumentException if the column names and column convertors do not match
     */
    public DatabaseStorage(Class<? extends T> storedObjectsClass, String dbConnUrl, Properties dbConnInfo, String tableName, String primaryKeyColumn, String[] columnNames, ColumnConvertor<T>[] columnConvertors) throws IllegalArgumentException {
        // Check provided values
        if (dbConnUrl == null)
            throw new IllegalArgumentException("Database connection cannot be null");
        if (tableName == null)
            throw new IllegalArgumentException("Table name cannot be null");
        if (primaryKeyColumn == null)
            throw new IllegalArgumentException("Primary key column name cannot be null");
        if (columnNames == null || columnConvertors == null || columnNames.length != columnConvertors.length)
            throw new IllegalArgumentException("Values of dataColumnNames and dataToColumnConvertors are incompatible or invalid");

        // Set values
        this.storedObjectsClass = storedObjectsClass;
        this.dbConnUrl = dbConnUrl;
        this.dbConnInfo = dbConnInfo;
        this.columnConvertors = columnConvertors;
        this.columnNames = columnNames;

        // Prepare SQL commands
        StringBuilder columnList = new StringBuilder();
        StringBuilder columnQList = new StringBuilder();
        for (int i = 0; i < columnNames.length; i++) {
            if (i > 0) {
                columnList.append(',');
                columnQList.append(',');
            }
            columnList.append(columnNames[i]);
            columnQList.append('?');
        }

        // Size
        sizeSQL = "select count(*) from " + tableName;
        // Insert
        StringBuilder sql = new StringBuilder("insert into ").append(tableName);
        sql.append('(').append(columnList).append(") values (").append(columnQList).append(')');
        insertSQL = sql.toString();
        // Select
        sql = new StringBuilder("select ").append(primaryKeyColumn).append(',').append(columnList);
        sql.append(" from ").append(tableName);
        selectSQL = sql.toString();
        // Read by data
        StringBuilder sqlByData = new StringBuilder(sql);
        for (int i = 0; i < columnNames.length; i++)
            sqlByData.append(i == 0 ? " where " : " and ").append(columnNames[i]).append(" = ?");
        readByDataSQL = sqlByData.toString();
        // Read
        sql.append(" where ").append(primaryKeyColumn).append(" = ?");
        readSQL = sql.toString();
        // Delete
        sql = new StringBuilder("delete from ").append(tableName);
        sql.append(" where ").append(primaryKeyColumn).append(" = ?");
        deleteSQL = sql.toString();
        // Delete all
        deleteAllSQL = "delete from " + tableName;
    }

    @Override
    public void finalize() throws Throwable {
        closeConnection();
        super.finalize();
    }

    public void destroy() throws Throwable {
        // Delete all records from the database
        getConnection().prepareStatement(deleteAllSQL).execute();
        closeConnection();
    }

    //****************** SQL connection ******************//

    /**
     * Returns the database connection of this storage.
     * @return the database connection
     * @throws SQLException if there was a problem connecting to the database
     */
    protected final Connection getConnection() throws SQLException {
        if (dbConnection != null && !dbConnection.isClosed())
            return dbConnection;
        return dbConnection = DriverManager.getConnection(dbConnUrl, dbConnInfo);
    }

    /**
     * Closes connection to the database.
     * @throws SQLException if there was an error while closing the connection
     */
    protected void closeConnection() throws SQLException {
        if (sizeStatement != null)
            sizeStatement.close();
        if (insertStatement != null)
            insertStatement.close();
        if (deleteStatement != null)
            deleteStatement.close();
        if (readStatement != null)
            readStatement.close();
        if (dbConnection != null)
            dbConnection.close();
    }

    /**
     * Converts the values from the given result set to the instance.
     *
     * @param resultSet the result set with the columns as specified by column convertors
     * @return an instance converted from database columns
     * @throws SQLException if there was a problem converting the values
     * @throws BucketStorageException if there was an error converting a column value
     */
    private T toValue(ResultSet resultSet) throws SQLException, BucketStorageException {
        T ret = null;
        for (int i = 0; i < columnConvertors.length; i++)
            ret = columnConvertors[i].convertFromColumnValue(ret, resultSet.getObject(i + 2)); // First column is primary key (and getObject is numbered from 1)
        return ret;
    }

    /**
     * Prepares and executes an SQL command.
     * The {@link ResultSet} returned by the execution can be retrieved by {@link PreparedStatement#getResultSet()}.
     * Note that if a {@link SQLRecoverableException} is thrown while executing,
     * the current connection is {@link #closeConnection() closed} and the command
     * retried.
     *
     * @param statement the previous cached statement that matches the given {@code sql} (can be <tt>null</tt>)
     * @param sql the SQL command to prepare and execute; one parameter (using "?") for the primary key or n parameters for data can be specified
     * @param primaryKey the value for the one SQL parameter of the primary key (if <tt>null</tt> the parameter is not set)
     * @param object the instance that is converted to database columns using {@link #columnConvertors} (if <tt>null</tt> the parameters are not set)
     * @return an executed prepared statement
     * @throws SQLException if there was an unrecoverable error when parsing or executing the SQL command
     * @throws BucketStorageException if there was an error converting a column value
     */
    protected final PreparedStatement execute(PreparedStatement statement, String sql, Integer primaryKey, T object) throws SQLException, BucketStorageException {
        for (;;) {
            // Prepare statement
            if (statement == null || statement.isClosed())
                statement = getConnection().prepareStatement(sql);

            // Map parameters
            if (primaryKey != null)
                statement.setObject(1, primaryKey);
            if (object != null) {
                for (int i = 0; i < columnConvertors.length; i++)
                    statement.setObject(i + 1, columnConvertors[i].convertToColumnValue(object));
            }

            // Execute query and handle recoverable exception
            try {
                statement.execute();
                return statement;
            } catch (SQLRecoverableException e) {
                closeConnection();
                try { Thread.sleep(connectionRetryTime); } catch (InterruptedException ignore) {}
            }
        }
    }


    //****************** Factory method ******************//
    
    /**
     * Creates a new database storage. The additional parameters are specified in the parameters map with
     * the following recognized key names:
     * <ul>
     *   <li><em>connectionURL</em> - the database connection URL (e.g. "jdbc:mysql://localhost/somedb")</li>
     *   <li><em>tableName</em> - the name of the table in the database</li>
     *   <li><em>primaryKeyColumn</em> - the name of the column that is the primary key of the table</li>
     *   <li><em>columnNames</em> - the names of columns where the data are stored</li>
     *   <li><em>columnConvertors</em> - the convertors that convert between the storage instances and database column;
     *          there must be one convertor for every data column name</li>
     * </ul>
     * All additinal parameters are passed to the database driver.
     * 
     * @param <T> the class of objects that the new storage will work with
     * @param storedObjectsClass the class of objects that the new storage will work with
     * @param parameters list of named parameters (see above)
     * @return a new database storage instance
     * @throws IllegalArgumentException if the parameters specified are invalid (null values, etc.)
     */
    public static <T> DatabaseStorage<T> create(Class<T> storedObjectsClass, Map<String, Object> parameters) throws IllegalArgumentException {
        String dbConnUrl = Convert.getParameterValue(parameters, "connectionURL", String.class, null);
        String tableName = Convert.getParameterValue(parameters, "tableName", String.class, null);
        String primaryKeyColumn = Convert.getParameterValue(parameters, "primaryKeyColumn", String.class, null);
        String[] columnNames = Convert.getParameterValue(parameters, "columnNames", String[].class, null);
        @SuppressWarnings("unchecked")
        ColumnConvertor<T>[] columnConvertors = Convert.getParameterValue(parameters, "columnConvertors", ColumnConvertor[].class, null); // This is NOT checked, but nothing can be done about it
        Properties properties = new Properties();
        for (Map.Entry<String, Object> entry : parameters.entrySet()) {
            if (entry.getValue() instanceof String)
                properties.setProperty(entry.getKey(), (String)entry.getValue());
        }
        DatabaseStorage<T> storage = new DatabaseStorage<T>(
                storedObjectsClass, dbConnUrl, properties, tableName, primaryKeyColumn, columnNames, columnConvertors);
        return storage;
    }


    //****************** Data access methods ******************//

    /**
     * Returns the class of objects that the this storage works with.
     * @return the class of objects that the this storage works with
     */
    public Class<? extends T> getStoredObjectsClass() {
        return storedObjectsClass;
    }

    /**
     * Returns <tt>true</tt> if this storage contains no elements.
     * @return <tt>true</tt> if this storage contains no elements
     */
    public boolean isEmpty() {
	return size() == 0;
    }


    //****************** Storage methods implementation ******************//

    /**
     * Returns the number of elements in this storage.
     * @return the number of elements in this storage
     */
    public synchronized int size() {
        try {
            sizeStatement = execute(sizeStatement, sizeSQL, null, null);
            ResultSet result = sizeStatement.getResultSet();
            try {
                if (!result.next())
                    throw new IllegalStateException("Size query returned no row - this should never happen!");
                return result.getInt(1);
            } finally {
                result.close();
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Cannot execute size query: " + e.getMessage(), e);
        } catch (BucketStorageException e) {
            throw new IllegalStateException("Cannot execute size query: " + e.getMessage(), e);
        }
    }

    public synchronized IntAddress<T> store(T object) throws BucketStorageException {
        try {
            insertStatement = execute(insertStatement, insertSQL, null, object);
            ResultSet generatedKeys = insertStatement.getGeneratedKeys();
            try {
                if (generatedKeys.next() && generatedKeys.getMetaData().getColumnCount() > 0)
                    return new IntAddress<T>(this, generatedKeys.getInt(1));
            } finally {
                generatedKeys.close();
            }

            // Generated keys failed, do full by-object select
            readByDataStatement = execute(readByDataStatement, readByDataSQL, null, object);
            generatedKeys = readByDataStatement.getResultSet();
            try {
                if (!generatedKeys.next())
                    throw new StorageFailureException("No generated column was found", null);
                return new IntAddress<T>(this, generatedKeys.getInt(1));
            } finally {
                generatedKeys.close();
            }
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }

    public synchronized T read(int address) throws BucketStorageException {
        try {
            readStatement = execute(readStatement, readSQL, address, null);
            ResultSet result = readStatement.getResultSet();
            try {
                if (!result.next())
                    throw new InvalidAddressException("There is no object with address " + address);
                return toValue(result);
            } finally {
                result.close();
            }
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }

    public synchronized void remove(int address) throws BucketStorageException, UnsupportedOperationException {
        try {
            deleteStatement = execute(deleteStatement, deleteSQL, address, null);
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }


    //****************** Default index implementation ******************//

    public boolean add(T object) throws BucketStorageException {
        return store(object) != null;
    }

    public IntStorageSearch<T> search() throws IllegalStateException {
        return search(null, null, null);
    }

    /**
     * Returns a name of a column that is compatible with the given comparator.
     * @param comparator the comparator for which to get column name
     * @return a column name or <tt>null</tt>
     */
    private String getComparatorCompatibleColumn(IndexComparator<?, ?> comparator) {
        for (int i = 0; i < columnConvertors.length; i++)
            if (columnConvertors[i].isColumnCompatible(comparator))
                return columnNames[i];
        return null;
    }

    public <C> IntStorageSearch<T> search(IndexComparator<? super C, ? super T> comparator, C key) throws IllegalStateException {
        return new DatabaseStorageSearch<C>(comparator, getComparatorCompatibleColumn(comparator), Collections.singletonList(key));
    }

    public <C> IntStorageSearch<T> search(IndexComparator<? super C, ? super T> comparator, Collection<? extends C> keys) throws IllegalStateException {
        return new DatabaseStorageSearch<C>(comparator, getComparatorCompatibleColumn(comparator), keys);
    }

    @SuppressWarnings("unchecked")
    public <C> IntStorageSearch<T> search(IndexComparator<? super C, ? super T> comparator, C from, C to) throws IllegalStateException {
        return new DatabaseStorageSearch<C>(comparator, getComparatorCompatibleColumn(comparator), from, to);
    }

    /**
     * Encapsulates a {@link ResultSet} search on the database storage.
     * All objects that have the value of the given column between from and to are returned.
     * @param <C> the type the boundaries used by the search
     */
    private class DatabaseStorageSearch<C> extends AbstractSearch<C, T> implements IntStorageSearch<T> {
        /** Name of the column that contains the searched keys */
        private final String columnName;
        /** Query result set that provides data for this search */
        private ResultSet resultSet;

        /**
         * Creates a new instance of DatabaseStorageSearch.
         * The search uses SQL "where" clause to limit the returned data
         * to those that have values of column {@code columnName} set to given keys.
         *
         * @param comparator the comparator that is used to compare the keys
         * @param columnName the column name that contains the keys (use <tt>null</tt> to do full scan)
         * @param keys list of keys to search for
         * @throws IllegalStateException if there was an error executing the query
         */
        private DatabaseStorageSearch(IndexComparator<? super C, ? super T> comparator, String columnName, Collection<? extends C> keys) throws IllegalStateException {
            // Pass the comparator only if the database column is not provided (and thus the filtering must be done)
            super(columnName != null ? null : comparator, keys);
            this.columnName = columnName;

            // Execute the query
            try {
                this.resultSet = executeQuery();
            } catch (SQLException e) {
                throw new IllegalStateException("Cannot search database: " + e.getMessage(), e);
            }
        }

        /**
         * Creates a new instance of DatabaseStorageSearch.
         * The search uses SQL "where" clause to limit the returned data
         * to those that have values of column {@code columnName} set to given keys.
         *
         * @param comparator the comparator that is used to compare the keys
         * @param columnName the column name that contains the keys (use <tt>null</tt> to do full scan)
         * @param fromKey the lower bound on the searched keys
         * @param toKey the upper bound on the searched keys
         * @throws IllegalStateException if there was an error executing the query
         */
        private DatabaseStorageSearch(IndexComparator<? super C, ? super T> comparator, String columnName, C fromKey, C toKey) throws IllegalStateException {
            // Pass the comparator only if the database column is not provided (and thus the filtering must be done)
            super(columnName != null ? null : comparator, fromKey, toKey);
            this.columnName = columnName;

            // Execute the query
            try {
                this.resultSet = executeQuery();
            } catch (SQLException e) {
                throw new IllegalStateException("Cannot search database: " + e.getMessage(), e);
            }
        }

        /**
         * Executes the encapsulated SQL query and returns the resulting resultset.
         * @return the SQL query result set
         * @throws SQLException if there was a problem executing the query
         */
        private ResultSet executeQuery() throws SQLException {
            do {
                // Prepare the statement
                PreparedStatement statement;
                if (columnName == null) {
                    statement = getConnection().prepareStatement(selectSQL);
                } else if (isKeyBounds()) {
                    statement = getConnection().prepareStatement(selectSQL + " where " + columnName + " between ? and ?");
                    statement.setObject(1, getKey(0));
                    statement.setObject(2, getKey(1));
                } else {
                    StringBuilder sql = new StringBuilder(selectSQL);
                    sql.append(" where ").append(columnName).append(" in (");
                    for (int i = 0; i < getKeyCount(); i++)
                        sql.append(i == 0 ? "?" : ",?");
                    sql.append(')');
                    statement = getConnection().prepareStatement(sql.toString());
                    for (int i = 0; i < getKeyCount(); i++)
                        statement.setObject(i + 1, getKey(i));
                }

                // Execute the query
                try {
                    return statement.executeQuery();
                } catch (SQLRecoverableException e) {
                    closeConnection();
                }
            } while (true);
        }

        @Override
        protected void finalize() throws Throwable {
            close();
            super.finalize();
        }

        @Override
        public AbstractSearch<C, T> clone() throws CloneNotSupportedException {
            try {
                DatabaseStorageSearch<C> ret = (DatabaseStorageSearch<C>)super.clone(); // This cast IS checked, because it is clonning
                ret.resultSet = ret.executeQuery();
                ret.resultSet.absolute(this.resultSet.getRow());
                return ret;
            } catch (SQLException e) {
                throw new CloneNotSupportedException(e.toString());
            }
        }

        @Override
        protected T readNext() throws BucketStorageException {
            try {
                if (!resultSet.next())
                    return null;
                return toValue(resultSet);
            } catch (SQLException e) {
                throw new StorageFailureException(e);
            }
        }

        @Override
        protected T readPrevious() throws BucketStorageException {
            try {
                if (!resultSet.previous())
                    return null;
                return toValue(resultSet);
            } catch (SQLException e) {
                throw new StorageFailureException(e);
            }
        }

        public IntAddress<T> getCurrentObjectAddress() throws IllegalStateException {
            return new IntAddress<T>(DatabaseStorage.this, getCurrentObjectIntAddress());
        }

        public int getCurrentObjectIntAddress() throws IllegalStateException {
            try {
                return resultSet.getInt(1);
            } catch (SQLException e) {
                throw new IllegalStateException("There is no current object", e);
            }
        }

        public void remove() throws IllegalStateException, BucketStorageException {
            DatabaseStorage.this.remove(getCurrentObjectIntAddress());
        }

        public void close() {
            try {
                resultSet.close();
            } catch (SQLException ignore) {
            }
        }
    }

    //****************** Implementations of common column convertors ******************//

    /**
     * Column convertor that uses a database BLOB into which instances of {@code T} are
     * {@link BinarySerializator binary serialized/deserialized}.
     *
     * @param <T> the class of instances that are serialized into the database
     */
    public static class BinarySerializableColumnConvertor<T> implements ColumnConvertor<T> {
        /** class serial id for serialization */
        private static final long serialVersionUID = 1L;

        //****************** Attributes ******************//

        /** Class of instances serialized into the database */
        private final Class<? extends T> storedObjectsClass;
        /** Serializator that is used for storing/restoring the data into the database */
        private final BinarySerializator serializator;


        //****************** Constructor ******************//

        /**
         * Creates a new instance of BinarySerializableColumnConvertor.
         *
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param serializator the serializator that is used for storing/restoring the data into the database
         */
        public BinarySerializableColumnConvertor(Class<? extends T> storedObjectsClass, BinarySerializator serializator) {
            this.storedObjectsClass = storedObjectsClass;
            this.serializator = serializator;
        }

        public Object convertToColumnValue(T instance) throws BucketStorageException {
            try {
                return serializator.write(instance, false).write();
            } catch (IOException e) {
                throw new StorageFailureException(e);
            }
        }

        public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
            try {
                return serializator.readObject(new BufferInputStream((byte[])column), storedObjectsClass);
            } catch (IOException e) {
                throw new StorageFailureException(e);
            }
        }

        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator) {
            return false;
        }
    }

    /**
     * Column convertor that stores/restores a {@link LocalAbstractObject#getLocatorURI() locator URI}
     * of {@link LocalAbstractObject}s stored in the database. Note that the associated column must
     * be {@link String}-compatible. When restoring an object, its key is set only if it has no key yet.
     */
    public static final ColumnConvertor<LocalAbstractObject> locatorColumnConvertor = new ColumnConvertor<LocalAbstractObject>() {
        private static final long serialVersionUID = 1L;

        public Object convertToColumnValue(LocalAbstractObject instance) throws BucketStorageException {
            return instance.getLocatorURI();
        }

        public LocalAbstractObject convertFromColumnValue(LocalAbstractObject value, Object column) throws BucketStorageException {
            if (value != null && column != null && value.getObjectKey() == null)
                value.setObjectKey(new AbstractObjectKey(column.toString()));
            return value;
        }

        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator) {
            return indexComparator == LocalAbstractObjectOrder.locatorToLocalObjectComparator;
        }
    };

    /**
     * Column convertor that stores/restores instances supported directly by the database.
     * For example, numbers can be accessed as {@link Integer}s or {@link Double}s, BLOBs as byte[] arrays, etc.
     */
    public static final ColumnConvertor<Object> trivialColumnConvertor = new ColumnConvertor<Object>() {
        private static final long serialVersionUID = 1L;

        public Object convertToColumnValue(Object instance) throws BucketStorageException {
            return instance;
        }

        public Object convertFromColumnValue(Object value, Object column) throws BucketStorageException {
            return column;
        }

        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator) {
            return indexComparator.equals(LocalAbstractObjectOrder.trivialObjectComparator);
        }
    };
}

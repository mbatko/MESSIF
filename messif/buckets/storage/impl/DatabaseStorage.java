/*
 *  This file is part of MESSIF library.
 *
 *  MESSIF library is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  MESSIF library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with MESSIF library.  If not, see <http://www.gnu.org/licenses/>.
 */
package messif.buckets.storage.impl;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLRecoverableException;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Properties;
import messif.buckets.BucketStorageException;
import messif.buckets.StorageFailureException;
import messif.buckets.index.IndexComparator;
import messif.buckets.index.LocalAbstractObjectOrder;
import messif.buckets.index.impl.AbstractSearch;
import messif.buckets.storage.IntAddress;
import messif.buckets.storage.IntStorageIndexed;
import messif.buckets.storage.IntStorageSearch;
import messif.buckets.storage.InvalidAddressException;
import messif.objects.LocalAbstractObject;
import messif.objects.MetaObject;
import messif.objects.keys.AbstractObjectKey;
import messif.objects.nio.BinarySerializator;
import messif.objects.nio.BufferInputStream;
import messif.utility.Convert;

/**
 * Database-based storage.
 * The objects in this storage are stored in a relational database that
 * is accessed via JDBC.
 *
 * <p>
 * A database table that will hold the stored data must be created.
 * The primary key of the table must be integer compatible and
 * must be automatically generated by the database. The data column
 * types must match the given column convertors.
 * </p>
 * 
 * @param <T> the class of objects stored in this storage
 * @author Michal Batko, Masaryk University, Brno, Czech Republic, batko@fi.muni.cz
 * @author Vlastislav Dohnal, Masaryk University, Brno, Czech Republic, dohnal@fi.muni.cz
 * @author David Novak, Masaryk University, Brno, Czech Republic, david.novak@fi.muni.cz
 */
public class DatabaseStorage<T> implements IntStorageIndexed<T>, Serializable {
    /** class serial id for serialization */
    private static final long serialVersionUID = 1L;

    //****************** Column convertor interface ******************//

    /**
     * Provides a conversion between database column data and object instances.
     *
     * @param <T> the type of the instance that is stored/read from the database column
     */
    public static interface ColumnConvertor<T> extends Serializable {
        /**
         * Returns a value that can be stored in a database column for the given instance.
         * @param instance the object instance from which to create a database value
         * @return a database value
         * @throws BucketStorageException if the value cannot be converted
         */
        public Object convertToColumnValue(T instance) throws BucketStorageException;

        /**
         * Returns whether the {@link #convertToColumnValue(java.lang.Object) convertToColumnValue}
         * method should be used when writing the object to database.
         * @return whether this column convertor is used (<tt>true</tt>)
         *          or should be skipped (<tt>false</tt>) when the object is
         *          stored into the storage
         */
        public boolean isConvertToColumnUsed();

        /**
         * Returns an instance of object from the database column value.
         * A value created by previous columns is provided in {@code value}, which can
         * be either replaced by a new value, modified by this method or left intact.
         *
         * @param value the instance created by previous column convertors
         * @param column the value of the column to convert
         * @return an instance created from the column value
         * @throws BucketStorageException if the value cannot be converted
         */
        public T convertFromColumnValue(T value, Object column) throws BucketStorageException;

        /**
         * Returns whether the {@link #convertFromColumnValue(T, java.lang.Object) convertFromColumnValue}
         * method should be used when reading the object from the database.
         * @return whether this column convertor is used (<tt>true</tt>)
         *          or should be skipped (<tt>false</tt>) when the object is
         *          retrieved from the storage
         */
        public boolean isConvertFromColumnUsed();

        /**
         * Returns <tt>true</tt> if the instance created by this convertor is compatible
         * with the given index comparator.
         * @param indexComparator the index comparator that is checked for compatibility
         * @return <tt>true</tt> if this column convertor works with compatible instances
         */
        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator);
    }


    //****************** Constants ******************//

    /** Number of miliseconds to sleep when an SQL command fail before another one is tried */
    private static final int connectionRetryTime = 500;


    //****************** Attributes ******************//

    /** Class of objects that the this storage works with */
    private final Class<? extends T> storedObjectsClass;
    /** Database connection URL */
    private final String dbConnUrl;
    /** Properties with database connection info */
    private final Properties dbConnInfo;
    /** Connection to database (according to {@link #dbConnUrl}) */
    private transient Connection dbConnection;
    /** List of column convertors */
    private final ColumnConvertor<T>[] columnConvertors;
    /** List of additional column names (same size as columnConvertors) */
    private final String[] columnNames;
    /** Number of objects SQL command */
    private final String sizeSQL;
    /** Cached prepared statement for size SQL */
    private transient PreparedStatement sizeStatement;
    /** Insert object SQL command */
    private final String insertSQL;
    /** Cached prepared statement for insert SQL */
    private transient PreparedStatement insertStatement;
    /** Update a single object (by primary key) SQL command */
    private final String updateSQL;
    /** Cached prepared statement for update SQL */
    private transient PreparedStatement updateStatement;
    /** Delete a single object (by primary key) SQL command */
    private final String deleteSQL;
    /** Cached prepared statement for delete SQL */
    private transient PreparedStatement deleteStatement;
    /** Delete all data SQL command */
    private final String deleteAllSQL;
    /** Read single object (by primary key) SQL command */
    private final String readSQL;
    /** Cached prepared statement for read SQL */
    private transient PreparedStatement readStatement;
    /** Read single object (by data) SQL command */
    private final String readByDataSQL;
    /** Cached prepared statement for readByData SQL */
    private transient PreparedStatement readByDataStatement;
    /** Select all data SQL command */
    private final String selectSQL;


    //****************** Constructor ******************//

    /**
     * Constructs an empty database storage.
     * Note that the connection is established when the first manipulation-method is called.
     *
     * @param storedObjectsClass the class of objects that the storage will work with
     * @param dbConnUrl the database connection URL (e.g. "jdbc:mysql://localhost/somedb")
     * @param dbConnInfo additional parameters of the connection (e.g. "user" and "password")
     * @param tableName the name of the table in the database
     * @param primaryKeyColumn the name of the column that is the primary key of the table
     * @param columnNames the names of columns where the data are stored
     * @param columnConvertors the convertors that convert between the storage instances and database column;
     *          there must be one convertor for every data column name from {@code columnNames}
     * @throws IllegalArgumentException if the column names and column convertors do not match
     * @throws SQLException if there was a problem connecting to the database
     */
    public DatabaseStorage(Class<? extends T> storedObjectsClass, String dbConnUrl, Properties dbConnInfo, String tableName, String primaryKeyColumn, String[] columnNames, ColumnConvertor<T>[] columnConvertors) throws IllegalArgumentException, SQLException {
        // Check provided values
        if (dbConnUrl == null)
            throw new IllegalArgumentException("Database connection cannot be null");
        if (tableName == null)
            throw new IllegalArgumentException("Table name cannot be null");
        if (primaryKeyColumn == null)
            throw new IllegalArgumentException("Primary key column name cannot be null");
        if (columnNames == null || columnConvertors == null || columnNames.length != columnConvertors.length)
            throw new IllegalArgumentException("Values of dataColumnNames and dataToColumnConvertors are incompatible or invalid");

        // Set values
        this.storedObjectsClass = storedObjectsClass;
        this.dbConnUrl = dbConnUrl;
        this.dbConnInfo = dbConnInfo;
        this.columnConvertors = columnConvertors;
        this.columnNames = columnNames;

        // Prepare SQL commands
        StringBuilder columnReadList = new StringBuilder();
        StringBuilder columnWriteList = new StringBuilder();
        StringBuilder columnUpdateList = new StringBuilder();
        StringBuilder columnQuestionMarkList = new StringBuilder();
        StringBuilder columnDataWhereList = new StringBuilder();
        for (int i = 0; i < columnNames.length; i++) {
            if (columnConvertors[i].isConvertFromColumnUsed()) {
                if (columnReadList.length() > 0)
                    columnReadList.append(',');
                columnReadList.append(columnNames[i]);
            }
            if (columnConvertors[i].isConvertToColumnUsed()) {
                if (columnWriteList.length() > 0)
                    columnWriteList.append(',');
                if (columnUpdateList.length() > 0)
                    columnUpdateList.append(',');
                if (columnQuestionMarkList.length() > 0)
                    columnQuestionMarkList.append(',');
                columnWriteList.append(columnNames[i]);
                columnUpdateList.append(columnNames[i]).append(" = ?");
                columnQuestionMarkList.append('?');
                columnDataWhereList.append(columnDataWhereList.length() > 0 ? " where " : " and ").
                        append(columnNames[i]).append(" = ?");
            }
        }

        // Size
        sizeSQL = "select count(*) from " + tableName;
        // Insert
        StringBuilder sql = new StringBuilder("insert into ").append(tableName);
        sql.append('(').append(columnWriteList).append(") values (").append(columnQuestionMarkList).append(')');
        insertSQL = sql.toString();
        // Select
        sql = new StringBuilder("select ").append(primaryKeyColumn).append(',').append(columnReadList);
        sql.append(" from ").append(tableName);
        selectSQL = sql.toString();
        // Read by data
        readByDataSQL = columnDataWhereList.insert(0, sql).toString();
        // Read
        sql.append(" where ").append(primaryKeyColumn).append(" = ?");
        readSQL = sql.toString();
        // Delete
        sql = new StringBuilder("delete from ").append(tableName);
        sql.append(" where ").append(primaryKeyColumn).append(" = ?");
        deleteSQL = sql.toString();
        columnUpdateList.insert(0, new StringBuilder("update ").append(tableName).append(" set "));
        updateSQL = columnUpdateList.append(" where ").append(primaryKeyColumn).append(" = ?").toString();
        // Delete all
        deleteAllSQL = "delete from " + tableName;

        // Connect to the database to fail fast if the URL is invalid
        getConnection();
    }

    /**
     * Constructs an empty database storage.
     * Note that the connection is established when the first manipulation-method is called.
     *
     * @param storedObjectsClass the class of objects that the storage will work with
     * @param dbConnUrl the database connection URL (e.g. "jdbc:mysql://localhost/somedb")
     * @param dbConnInfo additional parameters of the connection (e.g. "user" and "password")
     * @param tableName the name of the table in the database
     * @param primaryKeyColumn the name of the column that is the primary key of the table
     * @param columns a map with the names of columns in keys and the convertors that convert
     *          between the storage instances and database column in values (note
     *          that the map's keyset and values collection should return the data ordered)
     * @throws IllegalArgumentException if the column names and column convertors do not match
     * @throws SQLException if there was a problem connecting to the database
     */
    @SuppressWarnings("unchecked")
    public DatabaseStorage(Class<? extends T> storedObjectsClass, String dbConnUrl, Properties dbConnInfo, String tableName, String primaryKeyColumn, Map<String, ColumnConvertor<T>> columns) throws IllegalArgumentException, SQLException {
        this(storedObjectsClass, dbConnUrl, dbConnInfo, tableName, primaryKeyColumn,
                columns.keySet().toArray(new String[columns.size()]),
                columns.values().toArray(new ColumnConvertor[columns.size()])
        );
    }

    @Override
    public void finalize() throws Throwable {
        closeConnection();
        super.finalize();
    }

    public void destroy() throws Throwable {
        // Delete all records from the database
        getConnection().prepareStatement(deleteAllSQL).execute();
        closeConnection();
    }

    //****************** SQL connection ******************//

    /**
     * Returns the database connection of this storage.
     * @return the database connection
     * @throws SQLException if there was a problem connecting to the database
     */
    protected final Connection getConnection() throws SQLException {
        if (dbConnection != null && !dbConnection.isClosed())
            return dbConnection;
        return dbConnection = DriverManager.getConnection(dbConnUrl, dbConnInfo);
    }

    /**
     * Closes connection to the database.
     * @throws SQLException if there was an error while closing the connection
     */
    protected void closeConnection() throws SQLException {
        if (sizeStatement != null)
            sizeStatement.close();
        if (insertStatement != null)
            insertStatement.close();
        if (deleteStatement != null)
            deleteStatement.close();
        if (readStatement != null)
            readStatement.close();
        if (dbConnection != null)
            dbConnection.close();
    }

    /**
     * Converts the values from the given result set to the instance.
     *
     * @param resultSet the result set with the columns as specified by column convertors
     * @return an instance converted from database columns
     * @throws SQLException if there was a problem converting the values
     * @throws BucketStorageException if there was an error converting a column value
     */
    private T toValue(ResultSet resultSet) throws SQLException, BucketStorageException {
        T ret = null;
        int col = 2; // First column is primary key (and getObject is numbered from 1)
        for (int i = 0; i < columnConvertors.length; i++)
            if (columnConvertors[i].isConvertFromColumnUsed())
                ret = columnConvertors[i].convertFromColumnValue(ret, resultSet.getObject(col++));
        return ret;
    }

    /**
     * Prepares and executes an SQL command.
     * The {@link ResultSet} returned by the execution can be retrieved by {@link PreparedStatement#getResultSet()}.
     * Note that if a {@link SQLRecoverableException} is thrown while executing,
     * the current connection is {@link #closeConnection() closed} and the command
     * retried.
     *
     * @param statement the previous cached statement that matches the given {@code sql} (can be <tt>null</tt>)
     * @param sql the SQL command to prepare and execute; one parameter (using "?") for the primary key or n parameters for data can be specified
     * @param primaryKey the value for the one SQL parameter of the primary key (if <tt>null</tt> the parameter is not set)
     * @param object the instance that is converted to database columns using {@link #columnConvertors} (if <tt>null</tt> the parameters are not set)
     * @return an executed prepared statement
     * @throws SQLException if there was an unrecoverable error when parsing or executing the SQL command
     * @throws BucketStorageException if there was an error converting a column value
     */
    protected final PreparedStatement execute(PreparedStatement statement, String sql, Integer primaryKey, T object) throws SQLException, BucketStorageException {
        for (;;) {
            // Prepare statement
            if (statement == null || statement.isClosed())
                statement = getConnection().prepareStatement(sql);

            // Map parameters
            if (primaryKey != null && object == null)
                statement.setObject(1, primaryKey);
            if (object != null) {
                int col = 1;
                for (int i = 0; i < columnConvertors.length; i++)
                    if (columnConvertors[i].isConvertToColumnUsed())
                        statement.setObject(col++, columnConvertors[i].convertToColumnValue(object));
                if (primaryKey != null)
                    statement.setObject(col, primaryKey);
            }

            // Execute query and handle recoverable exception
            try {
                statement.execute();
                return statement;
            } catch (SQLRecoverableException e) {
                closeConnection();
                try { Thread.sleep(connectionRetryTime); } catch (InterruptedException ignore) {}
            }
        }
    }


    //****************** Factory method ******************//
    
    /**
     * Creates a new database storage. The additional parameters are specified in the parameters map with
     * the following recognized key names:
     * <ul>
     *   <li><em>connectionURL</em> - the database connection URL (e.g. "jdbc:mysql://localhost/somedb")</li>
     *   <li><em>tableName</em> - the name of the table in the database</li>
     *   <li><em>primaryKeyColumn</em> - the name of the column that is the primary key of the table</li>
     *   <li><em>columnNames</em> - the names of columns where the data are stored</li>
     *   <li><em>columnConvertors</em> - the convertors that convert between the storage instances and database column;
     *          there must be one convertor for every data column name</li>
     * </ul>
     * All additinal parameters are passed to the database driver.
     * 
     * @param <T> the class of objects that the new storage will work with
     * @param storedObjectsClass the class of objects that the new storage will work with
     * @param parameters list of named parameters (see above)
     * @return a new database storage instance
     * @throws IllegalArgumentException if the parameters specified are invalid (null values, etc.)
     * @throws SQLException if there was a problem connecting to the database
     */
    public static <T> DatabaseStorage<T> create(Class<T> storedObjectsClass, Map<String, Object> parameters) throws IllegalArgumentException, SQLException {
        String dbConnUrl = Convert.getParameterValue(parameters, "connectionURL", String.class, null);
        String tableName = Convert.getParameterValue(parameters, "tableName", String.class, null);
        String primaryKeyColumn = Convert.getParameterValue(parameters, "primaryKeyColumn", String.class, null);
        String[] columnNames = Convert.getParameterValue(parameters, "columnNames", String[].class, null);
        @SuppressWarnings("unchecked")
        ColumnConvertor<T>[] columnConvertors = Convert.getParameterValue(parameters, "columnConvertors", ColumnConvertor[].class, null); // This is NOT checked, but nothing can be done about it
        Properties properties = new Properties();
        for (Map.Entry<String, Object> entry : parameters.entrySet()) {
            if (entry.getValue() instanceof String)
                properties.setProperty(entry.getKey(), (String)entry.getValue());
        }
        DatabaseStorage<T> storage = new DatabaseStorage<T>(
                storedObjectsClass, dbConnUrl, properties, tableName, primaryKeyColumn, columnNames, columnConvertors);
        return storage;
    }


    //****************** Data access methods ******************//

    /**
     * Returns the class of objects that the this storage works with.
     * @return the class of objects that the this storage works with
     */
    public Class<? extends T> getStoredObjectsClass() {
        return storedObjectsClass;
    }

    /**
     * Returns <tt>true</tt> if this storage contains no elements.
     * @return <tt>true</tt> if this storage contains no elements
     */
    public boolean isEmpty() {
	return size() == 0;
    }


    //****************** Storage methods implementation ******************//

    /**
     * Returns the number of elements in this storage.
     * @return the number of elements in this storage
     */
    public synchronized int size() {
        try {
            sizeStatement = execute(sizeStatement, sizeSQL, null, null);
            ResultSet result = sizeStatement.getResultSet();
            try {
                if (!result.next())
                    throw new IllegalStateException("Size query returned no row - this should never happen!");
                return result.getInt(1);
            } finally {
                result.close();
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Cannot execute size query: " + e.getMessage(), e);
        } catch (BucketStorageException e) {
            throw new IllegalStateException("Cannot execute size query: " + e.getMessage(), e);
        }
    }

    public synchronized IntAddress<T> store(T object) throws BucketStorageException {
        try {
            insertStatement = execute(insertStatement, insertSQL, null, object);
            ResultSet generatedKeys = insertStatement.getGeneratedKeys();
            try {
                if (generatedKeys.next() && generatedKeys.getMetaData().getColumnCount() > 0)
                    return new IntAddress<T>(this, generatedKeys.getInt(1));
            } finally {
                generatedKeys.close();
            }

            // Generated keys failed, do full by-object select
            readByDataStatement = execute(readByDataStatement, readByDataSQL, null, object);
            generatedKeys = readByDataStatement.getResultSet();
            try {
                if (!generatedKeys.next())
                    throw new StorageFailureException("No generated column was found", null);
                return new IntAddress<T>(this, generatedKeys.getInt(1));
            } finally {
                generatedKeys.close();
            }
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }

    public synchronized T read(int address) throws BucketStorageException {
        try {
            readStatement = execute(readStatement, readSQL, address, null);
            ResultSet result = readStatement.getResultSet();
            try {
                if (!result.next())
                    throw new InvalidAddressException("There is no object with address " + address);
                return toValue(result);
            } finally {
                result.close();
            }
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }

    public synchronized void remove(int address) throws BucketStorageException, UnsupportedOperationException {
        try {
            deleteStatement = execute(deleteStatement, deleteSQL, address, null);
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }

    /**
     * Updates the object on address {@code address} with data from {@code object}.
     * Note that some storages may not support in-place update - the
     * {@link UnsupportedOperationException} is thrown when calling this method.
     * @param address the address of the object in the storage that is to be updated
     * @param object the new object data
     * @throws BucketStorageException if there was a problem storing the object
     * @throws UnsupportedOperationException if this operation is not supported by this storage
     */
    public synchronized void update(int address, T object) throws BucketStorageException, UnsupportedOperationException {
        try {
            updateStatement = execute(updateStatement, updateSQL, address, object);
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }


    //****************** Default index implementation ******************//

    public boolean add(T object) throws BucketStorageException {
        return store(object) != null;
    }

    public IntStorageSearch<T> search() throws IllegalStateException {
        return search(null, null, null);
    }

    /**
     * Returns a name of a column that is compatible with the given comparator.
     * @param comparator the comparator for which to get column name
     * @return a column name or <tt>null</tt>
     */
    private String getComparatorCompatibleColumn(IndexComparator<?, ?> comparator) {
        for (int i = 0; i < columnConvertors.length; i++)
            if (columnConvertors[i].isColumnCompatible(comparator))
                return columnNames[i];
        return null;
    }

    public <C> IntStorageSearch<T> search(IndexComparator<? super C, ? super T> comparator, C key) throws IllegalStateException {
        return new DatabaseStorageSearch<C>(comparator, getComparatorCompatibleColumn(comparator), Collections.singletonList(key));
    }

    public <C> IntStorageSearch<T> search(IndexComparator<? super C, ? super T> comparator, Collection<? extends C> keys) throws IllegalStateException {
        return new DatabaseStorageSearch<C>(comparator, getComparatorCompatibleColumn(comparator), keys);
    }

    @SuppressWarnings("unchecked")
    public <C> IntStorageSearch<T> search(IndexComparator<? super C, ? super T> comparator, C from, C to) throws IllegalStateException {
        return new DatabaseStorageSearch<C>(comparator, getComparatorCompatibleColumn(comparator), from, to);
    }

    /**
     * Encapsulates a {@link ResultSet} search on the database storage.
     * All objects that have the value of the given column between from and to are returned.
     * @param <C> the type the boundaries used by the search
     */
    private class DatabaseStorageSearch<C> extends AbstractSearch<C, T> implements IntStorageSearch<T> {
        /** Name of the column that contains the searched keys */
        private final String columnName;
        /** Query result set that provides data for this search */
        private ResultSet resultSet;

        /**
         * Creates a new instance of DatabaseStorageSearch.
         * The search uses SQL "where" clause to limit the returned data
         * to those that have values of column {@code columnName} set to given keys.
         *
         * @param comparator the comparator that is used to compare the keys
         * @param columnName the column name that contains the keys (use <tt>null</tt> to do full scan)
         * @param keys list of keys to search for
         * @throws IllegalStateException if there was an error executing the query
         */
        private DatabaseStorageSearch(IndexComparator<? super C, ? super T> comparator, String columnName, Collection<? extends C> keys) throws IllegalStateException {
            // Pass the comparator only if the database column is not provided (and thus the filtering must be done)
            super(columnName != null ? null : comparator, keys);
            this.columnName = columnName;

            // Execute the query
            try {
                this.resultSet = executeQuery();
            } catch (SQLException e) {
                throw new IllegalStateException("Cannot search database: " + e.getMessage(), e);
            }
        }

        /**
         * Creates a new instance of DatabaseStorageSearch.
         * The search uses SQL "where" clause to limit the returned data
         * to those that have values of column {@code columnName} set to given keys.
         *
         * @param comparator the comparator that is used to compare the keys
         * @param columnName the column name that contains the keys (use <tt>null</tt> to do full scan)
         * @param fromKey the lower bound on the searched keys
         * @param toKey the upper bound on the searched keys
         * @throws IllegalStateException if there was an error executing the query
         */
        private DatabaseStorageSearch(IndexComparator<? super C, ? super T> comparator, String columnName, C fromKey, C toKey) throws IllegalStateException {
            // Pass the comparator only if the database column is not provided (and thus the filtering must be done)
            super(columnName != null ? null : comparator, fromKey, toKey);
            this.columnName = columnName;

            // Execute the query
            try {
                this.resultSet = executeQuery();
            } catch (SQLException e) {
                throw new IllegalStateException("Cannot search database: " + e.getMessage(), e);
            }
        }

        /**
         * Executes the encapsulated SQL query and returns the resulting resultset.
         * @return the SQL query result set
         * @throws SQLException if there was a problem executing the query
         */
        private ResultSet executeQuery() throws SQLException {
            do {
                // Prepare the statement
                PreparedStatement statement;
                if (columnName == null) {
                    statement = getConnection().prepareStatement(selectSQL);
                } else if (isKeyBounds()) {
                    statement = getConnection().prepareStatement(selectSQL + " where " + columnName + " between ? and ?");
                    statement.setObject(1, getKey(0));
                    statement.setObject(2, getKey(1));
                } else {
                    StringBuilder sql = new StringBuilder(selectSQL);
                    sql.append(" where ").append(columnName).append(" in (");
                    for (int i = 0; i < getKeyCount(); i++)
                        sql.append(i == 0 ? "?" : ",?");
                    sql.append(')');
                    statement = getConnection().prepareStatement(sql.toString());
                    for (int i = 0; i < getKeyCount(); i++)
                        statement.setObject(i + 1, getKey(i));
                }

                // Execute the query
                try {
                    return statement.executeQuery();
                } catch (SQLRecoverableException e) {
                    closeConnection();
                }
            } while (true);
        }

        @Override
        protected void finalize() throws Throwable {
            close();
            super.finalize();
        }

        @Override
        public AbstractSearch<C, T> clone() throws CloneNotSupportedException {
            try {
                DatabaseStorageSearch<C> ret = (DatabaseStorageSearch<C>)super.clone(); // This cast IS checked, because it is clonning
                ret.resultSet = ret.executeQuery();
                ret.resultSet.absolute(this.resultSet.getRow());
                return ret;
            } catch (SQLException e) {
                throw new CloneNotSupportedException(e.toString());
            }
        }

        @Override
        protected T readNext() throws BucketStorageException {
            try {
                if (!resultSet.next())
                    return null;
                return toValue(resultSet);
            } catch (SQLException e) {
                throw new StorageFailureException(e);
            }
        }

        @Override
        protected T readPrevious() throws BucketStorageException {
            try {
                if (!resultSet.previous())
                    return null;
                return toValue(resultSet);
            } catch (SQLException e) {
                throw new StorageFailureException(e);
            }
        }

        public IntAddress<T> getCurrentObjectAddress() throws IllegalStateException {
            return new IntAddress<T>(DatabaseStorage.this, getCurrentObjectIntAddress());
        }

        public int getCurrentObjectIntAddress() throws IllegalStateException {
            try {
                return resultSet.getInt(1);
            } catch (SQLException e) {
                throw new IllegalStateException("There is no current object", e);
            }
        }

        public void remove() throws IllegalStateException, BucketStorageException {
            DatabaseStorage.this.remove(getCurrentObjectIntAddress());
        }

        public void close() {
            try {
                resultSet.close();
            } catch (SQLException ignore) {
            }
        }
    }

    //****************** Implementations of common column convertors ******************//

    /**
     * Column convertor that uses a database BLOB into which instances of {@code T} are
     * {@link BinarySerializator binary serialized/deserialized}.
     *
     * @param <T> the class of instances that are serialized into the database
     */
    public static class BinarySerializableColumnConvertor<T> implements ColumnConvertor<T> {
        /** class serial id for serialization */
        private static final long serialVersionUID = 1L;

        //****************** Attributes ******************//

        /** Class of instances serialized into the database */
        private final Class<? extends T> storedObjectsClass;
        /** Serializator that is used for storing/restoring the data into the database */
        private final BinarySerializator serializator;
        /** Flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage */
        private final boolean usedToRead;
        /** Flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage */
        private final boolean usedToWrite;


        //****************** Constructor ******************//

        /**
         * Creates a new instance of BinarySerializableColumnConvertor.
         *
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param serializator the serializator that is used for storing/restoring the data into the database
         * @param usedToRead a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage
         * @param usedToWrite a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage
         */
        public BinarySerializableColumnConvertor(Class<? extends T> storedObjectsClass, BinarySerializator serializator, boolean usedToRead, boolean usedToWrite) {
            this.storedObjectsClass = storedObjectsClass;
            this.serializator = serializator;
            this.usedToRead = usedToRead;
            this.usedToWrite = usedToWrite;
        }

        /**
         * Creates a new instance of BinarySerializableColumnConvertor.
         * Flags {@link #usedToRead usedToRead} and {@link #usedToWrite usedToWrite}
         * are both set to <tt>true</tt>.
         *
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param serializator the serializator that is used for storing/restoring the data into the database
         */
        public BinarySerializableColumnConvertor(Class<? extends T> storedObjectsClass, BinarySerializator serializator) {
            this(storedObjectsClass, serializator, true, true);
        }


        //****************** Implementation of ColumnConvertor interface ******************//

        public Object convertToColumnValue(T instance) throws BucketStorageException {
            try {
                return serializator.write(instance, false).write();
            } catch (IOException e) {
                throw new StorageFailureException(e);
            }
        }

        public boolean isConvertToColumnUsed() {
            return usedToWrite;
        }
        
        public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
            try {
                return serializator.readObject(new BufferInputStream((byte[])column), storedObjectsClass);
            } catch (IOException e) {
                throw new StorageFailureException(e);
            }
        }

        public boolean isConvertFromColumnUsed() {
            return usedToRead;
        }

        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator) {
            return false;
        }
    }

    /**
     * Column convertor that uses a database String into which instances of {@code T} are
     * serialized using {@link LocalAbstractObject#write(java.io.OutputStream) write}
     * method and deserialized using {@link LocalAbstractObject#create(java.lang.Class, java.lang.String)}.
     *
     * @param <T> the class of instances that are serialized into the database
     */
    public static class LocalAbstractObjectTextStreamColumnConvertor<T extends LocalAbstractObject> implements ColumnConvertor<T> {
        /** class serial id for serialization */
        private static final long serialVersionUID = 1L;

        //****************** Attributes ******************//

        /** Factory for reading objects from database */
        private final LocalAbstractObject.TextStreamFactory<? extends T> factory;
        /** Flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage */
        private final boolean usedToRead;
        /** Flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage */
        private final boolean usedToWrite;


        //****************** Constructor ******************//

        /**
         * Creates a new instance of LocalAbstractObjectTextStreamColumnConvertor.
         *
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param usedToRead a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage
         * @param usedToWrite a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage
         * @param additionalArguments additional arguments for the constructor
         */
        public LocalAbstractObjectTextStreamColumnConvertor(Class<? extends T> storedObjectsClass, boolean usedToRead, boolean usedToWrite, Object... additionalArguments) {
            this.factory = new LocalAbstractObject.TextStreamFactory<T>(storedObjectsClass, additionalArguments);
            this.usedToRead = usedToRead;
            this.usedToWrite = usedToWrite;
        }

        /**
         * Creates a new instance of LocalAbstractObjectTextStreamColumnConvertor.
         * Flags {@link #usedToRead usedToRead} and {@link #usedToWrite usedToWrite}
         * are both set to <tt>true</tt>.
         *
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         */
        public LocalAbstractObjectTextStreamColumnConvertor(Class<? extends T> storedObjectsClass) {
            this(storedObjectsClass, true, true);
        }


        //****************** Implementation of ColumnConvertor interface ******************//

        public Object convertToColumnValue(LocalAbstractObject instance) throws BucketStorageException {
            try {
                ByteArrayOutputStream data = new ByteArrayOutputStream();
                instance.write(data);
                data.close();
                // Remove trailing newline
                String ret = data.toString();
                return ret.charAt(ret.length() - 1) == '\n' ? ret.substring(0, ret.length() - 1) : ret;
            } catch (IOException e) {
                throw new StorageFailureException(e);
            } catch (RuntimeException e) {
                throw new StorageFailureException(e);
            }
        }

        public boolean isConvertToColumnUsed() {
            return usedToWrite;
        }

        public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
            try {
                return factory.create((String)column);
            } catch (InvocationTargetException e) {
                throw new StorageFailureException(e.getCause());
            }
        }

        public boolean isConvertFromColumnUsed() {
            return usedToRead;
        }

        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator) {
            return false;
        }
    }

    /**
     * Column convertor that uses a database String into which instances of
     * an {@link LocalAbstractObject} encapsulated in {@code T} are
     * serialized using {@link LocalAbstractObject#write(java.io.OutputStream) write}
     * method and deserialized using {@link LocalAbstractObject#create(java.lang.Class, java.lang.String)}.
     *
     * Note that this convertor can be used only to writing.
     *
     * @param <T> the class of instances that are serialized into the database
     */
    public static class MetaObjectTextStreamColumnConvertor<T extends MetaObject> extends LocalAbstractObjectTextStreamColumnConvertor<T> {
        /** class serial id for serialization */
        private static final long serialVersionUID = 1L;

        //****************** Attributes ******************//

        /** Name of the {@link LocalAbstractObject} encapsulated in the {@link MetaObject} */
        private final String encapsulatedObjectName;


        //****************** Constructor ******************//

        /**
         * Creates a new instance of MetaObjectTextStreamColumnConvertor.
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param encapsulatedObjectName the name of the {@link LocalAbstractObject} encapsulated in the {@link MetaObject}
         */
        public MetaObjectTextStreamColumnConvertor(Class<? extends T> storedObjectsClass, String encapsulatedObjectName) {
            super(storedObjectsClass, false, true);
            this.encapsulatedObjectName = encapsulatedObjectName;
        }


        //****************** Implementation of ColumnConvertor interface ******************//

        @Override
        public Object convertToColumnValue(T instance) throws BucketStorageException {
            return super.convertToColumnValue(instance.getObject(encapsulatedObjectName));
        }

        @Override
        public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
            throw new UnsupportedOperationException("MetaObjectTextStreamColumnConvertor should never be used when retrieving object from storage");
        }

    }

    /**
     * Column convertor that uses a bean property to decompose/restore
     * a given object to/from a database storage. Typically, a bean is decomposed
     * into several primitive columns in the database by using property getter method
     * and the restored by using setter methods.
     *
     * @param <T> the class of instances that are serialized into the database
     */
    public static class BeanPropertyColumnConvertor<T> implements ColumnConvertor<T> {
        /** class serial id for serialization */
        private static final long serialVersionUID = 1L;

        //****************** Attributes ******************//

        /** Class of instances serialized into the database */
        private final Class<? extends T> storedObjectsClass;
        /** Method used to read the value of the object's property */
        private final Method getterMethod;
        /** Method used to write the value of the object's property */
        private final Method setterMethod;


        //****************** Constructor ******************//

        /**
         * Creates a new instance of BeanPropertyColumnConvertor.
         *
         * @param propertyName the name of the property of the {@code storedObjectsClass} to use
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param usedToRead a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage
         * @param usedToWrite a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage
         * @throws IllegalArgumentException if there was no property of the given name in {@code storedObjectsClass}
         */
        public BeanPropertyColumnConvertor(String propertyName, Class<? extends T> storedObjectsClass, boolean usedToRead, boolean usedToWrite) throws IllegalArgumentException {
            this.storedObjectsClass = storedObjectsClass;
            PropertyDescriptor propertyDescriptor = null;
            try {
                BeanInfo beanInfo = Introspector.getBeanInfo(storedObjectsClass);
                for (PropertyDescriptor pd : beanInfo.getPropertyDescriptors()) {
                    if (propertyName.equals(pd.getName()))
                        propertyDescriptor = pd;
                }
            } catch (IntrospectionException e) {
                throw new IllegalArgumentException("Property '" + propertyName + "' on " + storedObjectsClass + " cannot be used", e);
            }
            if (propertyDescriptor == null)
                throw new IllegalArgumentException("Property '" + propertyName + "' on " + storedObjectsClass + " was not found");

            if (usedToRead) {
                setterMethod = propertyDescriptor.getWriteMethod();
                if (setterMethod == null)
                    throw new IllegalArgumentException("Property '" + propertyName + "' on " + storedObjectsClass + " cannot be used when reading the object from the database");
            } else {
                setterMethod = null;
            }

            if (usedToWrite) {
                getterMethod = propertyDescriptor.getReadMethod();
                if (getterMethod == null)
                    throw new IllegalArgumentException("Property '" + propertyName + "' on " + storedObjectsClass + " cannot be used when storing the object to the database");
            } else {
                getterMethod = null;
            }
        }


        //****************** Implementation of ColumnConvertor interface ******************//

        public Object convertToColumnValue(T instance) throws BucketStorageException {
            try {
                return getterMethod.invoke(instance);
            } catch (InvocationTargetException e) {
                throw new StorageFailureException(e.getCause());
            } catch (Exception e) {
                throw new StorageFailureException(e);
            }
        }

        public boolean isConvertToColumnUsed() {
            return getterMethod != null;
        }

        public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
            try {
                // Create a new bean instance if it does not exist yet
                if (value == null)
                    value = storedObjectsClass.newInstance();
                setterMethod.invoke(value, column);
                return value;
            } catch (InvocationTargetException e) {
                throw new StorageFailureException(e.getCause());
            } catch (Exception e) {
                throw new StorageFailureException(e);
            }
        }

        public boolean isConvertFromColumnUsed() {
            return setterMethod != null;
        }

        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator) {
            return indexComparator != null &&
                    indexComparator.equals(LocalAbstractObjectOrder.trivialObjectComparator) &&
                    Comparable.class.isAssignableFrom(setterMethod.getReturnType());
        }
    }

    /**
     * Column convertor that stores/restores a {@link LocalAbstractObject#getLocatorURI() locator URI}
     * of {@link LocalAbstractObject}s stored in the database. Note that the associated column must
     * be {@link String}-compatible. When restoring an object, its key is set only if it has no key yet.
     */
    public static final ColumnConvertor<LocalAbstractObject> locatorColumnConvertor = new ColumnConvertor<LocalAbstractObject>() {
        private static final long serialVersionUID = 1L;

        public Object convertToColumnValue(LocalAbstractObject instance) throws BucketStorageException {
            return instance.getLocatorURI();
        }

        public boolean isConvertFromColumnUsed() {
            return true;
        }

        public LocalAbstractObject convertFromColumnValue(LocalAbstractObject value, Object column) throws BucketStorageException {
            if (value != null && column != null && value.getObjectKey() == null)
                value.setObjectKey(new AbstractObjectKey(column.toString()));
            return value;
        }

        public boolean isConvertToColumnUsed() {
            return true;
        }

        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator) {
            return indexComparator != null && indexComparator.equals(LocalAbstractObjectOrder.locatorToLocalObjectComparator);
        }
    };

    /**
     * Returns a column convertor that stores/restores a {@link LocalAbstractObject#getLocatorURI() locator URI}
     * of {@link LocalAbstractObject}s stored in the database. In fact, this method
     * just returns the generic-typed {@link #locatorColumnConvertor}.
     * @param <T> the class of object for which to get the locator column convertor
     * @param objectClass the class of object for which to get the locator column convertor
     * @return a column convertor
     */
    @SuppressWarnings("unchecked")
    public static <T extends LocalAbstractObject> ColumnConvertor<T> getLocatorColumnConvertor(Class<T> objectClass) {
        return (ColumnConvertor)locatorColumnConvertor;
    }

    /**
     * Column convertor that stores/restores instances supported directly by the database.
     * For example, numbers can be accessed as {@link Integer}s or {@link Double}s, BLOBs as byte[] arrays, etc.
     * Note that this convertor states a compatibility with {@link LocalAbstractObjectOrder#trivialObjectComparator}
     * since practically all database types are inherently {@link Comparable}.
     */
    public static final ColumnConvertor<Object> trivialColumnConvertor = new ColumnConvertor<Object>() {
        private static final long serialVersionUID = 1L;

        public Object convertToColumnValue(Object instance) throws BucketStorageException {
            return instance;
        }

        public boolean isConvertFromColumnUsed() {
            return true;
        }

        public Object convertFromColumnValue(Object value, Object column) throws BucketStorageException {
            return column;
        }

        public boolean isConvertToColumnUsed() {
            return true;
        }

        public boolean isColumnCompatible(IndexComparator<?, ?> indexComparator) {
            return indexComparator != null && indexComparator.equals(LocalAbstractObjectOrder.trivialObjectComparator);
        }
    };
}

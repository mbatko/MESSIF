/*
 *  This file is part of MESSIF library.
 *
 *  MESSIF library is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  MESSIF library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with MESSIF library.  If not, see <http://www.gnu.org/licenses/>.
 */
package messif.buckets.storage.impl;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import messif.buckets.BucketStorageException;
import messif.buckets.StorageFailureException;
import messif.buckets.index.IndexComparator;
import messif.buckets.index.LocalAbstractObjectOrder;
import messif.buckets.index.impl.AbstractSearch;
import messif.buckets.storage.IntAddress;
import messif.buckets.storage.IntStorageIndexed;
import messif.buckets.storage.IntStorageSearch;
import messif.buckets.storage.InvalidAddressException;
import messif.objects.LocalAbstractObject;
import messif.objects.LocalAbstractObject.TextStreamFactory;
import messif.objects.MetaObject;
import messif.objects.keys.AbstractObjectKey;
import messif.objects.nio.BinarySerializator;
import messif.objects.nio.BufferInputStream;
import messif.utility.Convert;
import messif.utility.ExtendedDatabaseConnection;

/**
 * Database-based storage.
 * The objects in this storage are stored in a relational database that
 * is accessed via JDBC.
 *
 * <p>
 * A database table that will hold the stored data must be created.
 * The primary key of the table must be integer compatible and
 * must be automatically generated by the database. The data column
 * types must match the given column convertors.
 * </p>
 * 
 * @param <T> the class of objects stored in this storage
 * @author Michal Batko, Masaryk University, Brno, Czech Republic, batko@fi.muni.cz
 * @author Vlastislav Dohnal, Masaryk University, Brno, Czech Republic, dohnal@fi.muni.cz
 * @author David Novak, Masaryk University, Brno, Czech Republic, david.novak@fi.muni.cz
 */
public class DatabaseStorage<T> extends ExtendedDatabaseConnection implements IntStorageIndexed<T>, Serializable {
    /** class serial id for serialization */
    private static final long serialVersionUID = 3L;

    //****************** Column convertor interface ******************//

    /**
     * Provides a conversion between database column data and object instances.
     *
     * @param <T> the type of the instance that is stored/read from the database column
     */
    public static interface ColumnConvertor<T> extends Serializable {
        /**
         * Returns a value that can be stored in a database column for the given instance.
         * @param instance the object instance from which to create a database value
         * @return a database value
         * @throws BucketStorageException if the value cannot be converted
         */
        public Object convertToColumnValue(T instance) throws BucketStorageException;

        /**
         * Returns whether the {@link #convertToColumnValue(java.lang.Object) convertToColumnValue}
         * method should be used when writing the object to database.
         * @return whether this column convertor is used (<tt>true</tt>)
         *          or should be skipped (<tt>false</tt>) when the object is
         *          stored into the storage
         */
        public boolean isConvertToColumnUsed();

        /**
         * Returns an instance of object from the database column value.
         * A value created by previous columns is provided in {@code value}, which can
         * be either replaced by a new value, modified by this method or left intact.
         *
         * @param value the instance created by previous column convertors
         * @param column the value of the column to convert
         * @return an instance created from the column value
         * @throws BucketStorageException if the value cannot be converted
         */
        public T convertFromColumnValue(T value, Object column) throws BucketStorageException;

        /**
         * Returns whether the {@link #convertFromColumnValue convertFromColumnValue}
         * method should be used when reading the object from the database.
         * @return whether this column convertor is used (<tt>true</tt>)
         *          or should be skipped (<tt>false</tt>) when the object is
         *          retrieved from the storage
         */
        public boolean isConvertFromColumnUsed();
    }

    /**
     * Extension of the {@link ColumnConvertor} that allows a direct searching
     * by the column value in the database. This usually means that there is
     * a unique index on that column.
     *
     * @param <K> the type of the key arguments of the comparison
     * @param <T> the type of the instance that is stored/read from the database column
     */
    public static interface SearchableColumnConvertor<K, T> extends ColumnConvertor<T> {
        /**
         * Returns <tt>true</tt> if the instance created by this convertor is compatible
         * with the given index comparator. If <tt>true</tt> is returned, the column
         * is used to search for the value.
         * @param indexComparator the index comparator that is checked for compatibility
         * @return <tt>true</tt> if this column convertor works with compatible instances
         */
        public boolean isColumnCompatible(IndexComparator<?, ? super T> indexComparator);

        /**
         * Returns a column value that can be used to search inside the database.
         * @param key the key from which to create a database value
         * @return a database value
         */
        public Object convertKeyToColumnValue(K key);
    }


    //****************** Attributes ******************//

    /** Class of objects that the this storage works with */
    private final Class<? extends T> storedObjectsClass;
    /** Name of the column that is the primary key of the table */
    private final String primaryKeyColumn;
    /** List of column convertors */
    private final ColumnConvertor<T>[] columnConvertors;
    /** List of additional column names (same size as columnConvertors) */
    private final String[] columnNames;
    /** Number of objects SQL command */
    private final String sizeSQL;
    /** Cached prepared statement for size SQL */
    private transient PreparedStatement sizeStatement;
    /** Insert object SQL command */
    private final String insertSQL;
    /** Cached prepared statement for insert SQL */
    private transient PreparedStatement insertStatement;
    /** Update a single object (by primary key) SQL command */
    private final String updateSQL;
    /** Cached prepared statement for update SQL */
    private transient PreparedStatement updateStatement;
    /** Delete a single object (by primary key) SQL command */
    private final String deleteSQL;
    /** Cached prepared statement for delete SQL */
    private transient PreparedStatement deleteStatement;
    /** Delete all data SQL command */
    private final String deleteAllSQL;
    /** Read single object (by primary key) SQL command */
    private final String readSQL;
    /** Cached prepared statement for read SQL */
    private transient PreparedStatement readStatement;
    /** Read single object (by data) SQL command */
    private final String readByDataSQL;
    /** Cached prepared statement for readByData SQL */
    private transient PreparedStatement readByDataStatement;
    /** Select all data SQL command */
    private final String selectSQL;


    //****************** Constructor ******************//

    /**
     * Constructs an empty database storage.
     *
     * @param storedObjectsClass the class of objects that the storage will work with
     * @param dbConnUrl the database connection URL (e.g. "jdbc:mysql://localhost/somedb")
     * @param dbConnInfo additional parameters of the connection (e.g. "user" and "password")
     * @param dbDriverClass class of the database driver to use (can be <tt>null</tt> if the driver is already registered)
     * @param tableName the name of the table in the database
     * @param primaryKeyColumn the name of the column that is the primary key of the table
     * @param columnNames the names of columns where the data are stored
     * @param columnConvertors the convertors that convert between the storage instances and database column;
     *          there must be one convertor for every data column name from {@code columnNames}
     * @throws IllegalArgumentException if the column names and column convertors do not match
     * @throws SQLException if there was a problem connecting to the database
     */
    public DatabaseStorage(Class<? extends T> storedObjectsClass, String dbConnUrl, Properties dbConnInfo, String dbDriverClass, String tableName, String primaryKeyColumn, String[] columnNames, ColumnConvertor<T>[] columnConvertors) throws IllegalArgumentException, SQLException {
        super(dbConnUrl, dbConnInfo, dbDriverClass);

        // Check provided values
        if (tableName == null)
            throw new IllegalArgumentException("Table name cannot be null");
        if (primaryKeyColumn == null)
            throw new IllegalArgumentException("Primary key column name cannot be null");
        if (columnNames == null || columnConvertors == null || columnNames.length != columnConvertors.length)
            throw new IllegalArgumentException("Values of dataColumnNames and dataToColumnConvertors are incompatible or invalid");

        // Set values
        this.storedObjectsClass = storedObjectsClass;
        this.primaryKeyColumn = primaryKeyColumn;
        this.columnConvertors = columnConvertors;
        this.columnNames = columnNames;

        // Prepare SQL commands
        StringBuilder columnReadList = new StringBuilder();
        StringBuilder columnWriteList = new StringBuilder();
        StringBuilder columnUpdateList = new StringBuilder();
        StringBuilder columnQuestionMarkList = new StringBuilder();
        StringBuilder columnDataWhereList = new StringBuilder();
        for (int i = 0; i < columnNames.length; i++) {
            if (columnConvertors[i].isConvertFromColumnUsed()) {
                if (columnReadList.length() > 0)
                    columnReadList.append(',');
                columnReadList.append(columnNames[i]);
            }
            if (columnConvertors[i].isConvertToColumnUsed()) {
                if (columnWriteList.length() > 0)
                    columnWriteList.append(',');
                if (columnUpdateList.length() > 0)
                    columnUpdateList.append(',');
                if (columnQuestionMarkList.length() > 0)
                    columnQuestionMarkList.append(',');
                columnWriteList.append(columnNames[i]);
                columnUpdateList.append(columnNames[i]).append(" = ?");
                columnQuestionMarkList.append('?');
                columnDataWhereList.append(columnDataWhereList.length() == 0 ? " where " : " and ").
                        append(columnNames[i]).append(" = ?");
            }
        }

        // Size
        sizeSQL = "select count(*) from " + tableName;
        // Insert
        StringBuilder sql = new StringBuilder("insert into ").append(tableName);
        sql.append('(').append(columnWriteList).append(") values (").append(columnQuestionMarkList).append(')');
        insertSQL = sql.toString();
        // Select
        sql = new StringBuilder("select ").append(primaryKeyColumn).append(',').append(columnReadList);
        sql.append(" from ").append(tableName);
        selectSQL = sql.toString();
        // Read by data
        readByDataSQL = columnDataWhereList.insert(0, sql).toString();
        // Read
        sql.append(" where ").append(primaryKeyColumn).append(" = ?");
        readSQL = sql.toString();
        // Delete
        sql = new StringBuilder("delete from ").append(tableName);
        sql.append(" where ").append(primaryKeyColumn).append(" = ?");
        deleteSQL = sql.toString();
        columnUpdateList.insert(0, new StringBuilder("update ").append(tableName).append(" set "));
        updateSQL = columnUpdateList.append(" where ").append(primaryKeyColumn).append(" = ?").toString();
        // Delete all
        deleteAllSQL = "delete from " + tableName;
    }

    /**
     * Constructs an empty database storage.
     *
     * @param storedObjectsClass the class of objects that the storage will work with
     * @param dbConnUrl the database connection URL (e.g. "jdbc:mysql://localhost/somedb")
     * @param dbConnInfo additional parameters of the connection (e.g. "user" and "password")
     * @param tableName the name of the table in the database
     * @param primaryKeyColumn the name of the column that is the primary key of the table
     * @param columnNames the names of columns where the data are stored
     * @param columnConvertors the convertors that convert between the storage instances and database column;
     *          there must be one convertor for every data column name from {@code columnNames}
     * @throws IllegalArgumentException if the column names and column convertors do not match
     * @throws SQLException if there was a problem connecting to the database
     */
    public DatabaseStorage(Class<? extends T> storedObjectsClass, String dbConnUrl, Properties dbConnInfo, String tableName, String primaryKeyColumn, String[] columnNames, ColumnConvertor<T>[] columnConvertors) throws IllegalArgumentException, SQLException {
        this(storedObjectsClass, dbConnUrl, dbConnInfo, null, tableName, primaryKeyColumn, columnNames, columnConvertors);
    }

    /**
     * Constructs an empty database storage.
     *
     * @param storedObjectsClass the class of objects that the storage will work with
     * @param dbConnUrl the database connection URL (e.g. "jdbc:mysql://localhost/somedb")
     * @param dbConnInfo additional parameters of the connection (e.g. "user" and "password")
     * @param dbDriverClass class of the database driver to use (can be <tt>null</tt> if the driver is already registered)
     * @param tableName the name of the table in the database
     * @param primaryKeyColumn the name of the column that is the primary key of the table
     * @param columns a map with the names of columns in keys and the convertors that convert
     *          between the storage instances and database column in values (note
     *          that the map's keyset and values collection should return the data ordered)
     * @throws IllegalArgumentException if the column names and column convertors do not match
     * @throws SQLException if there was a problem connecting to the database
     */
    @SuppressWarnings("unchecked")
    public DatabaseStorage(Class<? extends T> storedObjectsClass, String dbConnUrl, Properties dbConnInfo, String dbDriverClass, String tableName, String primaryKeyColumn, Map<String, ColumnConvertor<T>> columns) throws IllegalArgumentException, SQLException {
        this(storedObjectsClass, dbConnUrl, dbConnInfo, dbDriverClass, tableName, primaryKeyColumn,
                columns.keySet().toArray(new String[columns.size()]),
                columns.values().toArray(new ColumnConvertor[columns.size()])
        );
    }

    @Override
    public void destroy() throws Throwable {
        // Delete all records from the database
        prepareAndExecute(null, deleteAllSQL, false);
        closeConnection();
    }


    //****************** Column conversion support ******************//

    /**
     * Closes connection to the database.
     * @throws SQLException if there was an error while closing the connection
     */
    @Override
    protected void closeConnection() throws SQLException {
        try {
            if (sizeStatement != null)
                sizeStatement.close();
            if (insertStatement != null)
                insertStatement.close();
            if (deleteStatement != null)
                deleteStatement.close();
            if (updateStatement != null)
                updateStatement.close();
            if (readStatement != null)
                readStatement.close();
            if (readByDataStatement != null)
                readByDataStatement.close();
        } catch (Exception ignore) {
        }
        super.closeConnection();
    }

    /**
     * Converts the values from the given result set to the instance.
     *
     * @param resultSet the result set with the columns as specified by column convertors
     * @return an instance converted from database columns
     * @throws SQLException if there was a problem converting the values
     * @throws BucketStorageException if there was an error converting a column value
     */
    private T toValue(ResultSet resultSet) throws SQLException, BucketStorageException {
        T ret = null;
        int col = 2; // First column is primary key (and getObject is numbered from 1)
        for (int i = 0; i < columnConvertors.length; i++)
            if (columnConvertors[i].isConvertFromColumnUsed())
                ret = columnConvertors[i].convertFromColumnValue(ret, resultSet.getObject(col++));
        return ret;
    }

    /**
     * Prepares and executes an SQL command.
     * The {@link ResultSet} returned by the execution can be retrieved by {@link PreparedStatement#getResultSet()}.
     * Note that if a {@link java.sql.SQLRecoverableException} is thrown while executing,
     * the current connection is {@link #closeConnection() closed} and the command
     * retried.
     *
     * @param statement the previous cached statement that matches the given {@code sql} (can be <tt>null</tt>)
     * @param sql the SQL command to prepare and execute; one parameter (using "?") for the primary key or n parameters for data can be specified
     * @param primaryKey the value for the one SQL parameter of the primary key (if <tt>null</tt> the parameter is not set)
     * @param object the instance that is converted to database columns using {@link #columnConvertors} (if <tt>null</tt> the parameters are not set)
     * @param returnGeneratedKeys flag whether to set the {@link java.sql.Statement#RETURN_GENERATED_KEYS} on the prepared statement
     * @return an executed prepared statement
     * @throws SQLFeatureNotSupportedException if the {@link Statement#RETURN_GENERATED_KEYS} is not supported by the driver
     * @throws SQLException if there was an unrecoverable error when parsing or executing the SQL command
     * @throws BucketStorageException if there was an error converting a column value
     */
    protected final PreparedStatement execute(PreparedStatement statement, String sql, Integer primaryKey, T object, boolean returnGeneratedKeys) throws SQLFeatureNotSupportedException, SQLException, BucketStorageException {
        List<Object> parameters = new ArrayList<Object>(columnConvertors.length);

        // Map parameters
        if (primaryKey != null && object == null)
            parameters.add(primaryKey);
        if (object != null) {
            for (int i = 0; i < columnConvertors.length; i++)
                if (columnConvertors[i].isConvertToColumnUsed())
                    parameters.add(columnConvertors[i].convertToColumnValue(object));
            if (primaryKey != null)
                parameters.add(primaryKey);
        }

        return prepareAndExecute(statement, sql, returnGeneratedKeys, parameters.toArray());
    }


    //****************** Factory method ******************//
    
    /**
     * Creates a new database storage. The additional parameters are specified in the parameters map with
     * the following recognized key names:
     * <ul>
     *   <li><em>connectionURL</em> - the database connection URL (e.g. "jdbc:mysql://localhost/somedb")</li>
     *   <li><em>driverClass</em> - the class of the database driver to use
     *   <li><em>tableName</em> - the name of the table in the database</li>
     *   <li><em>primaryKeyColumn</em> - the name of the column that is the primary key of the table</li>
     *   <li><em>columnNames</em> - the names of columns where the data are stored</li>
     *   <li><em>columnConvertors</em> - the convertors that convert between the storage instances and database column;
     *          there must be one convertor for every data column name</li>
     * </ul>
     * All additinal parameters are passed to the database driver.
     * 
     * @param <T> the class of objects that the new storage will work with
     * @param storedObjectsClass the class of objects that the new storage will work with
     * @param parameters list of named parameters (see above)
     * @return a new database storage instance
     * @throws IllegalArgumentException if the parameters specified are invalid (null values, etc.)
     * @throws SQLException if there was a problem connecting to the database
     */
    public static <T> DatabaseStorage<T> create(Class<T> storedObjectsClass, Map<String, Object> parameters) throws IllegalArgumentException, SQLException {
        String dbConnUrl = Convert.getParameterValue(parameters, "connectionURL", String.class, null);
        String driverClass = Convert.getParameterValue(parameters, "driverClass", String.class, null);
        String tableName = Convert.getParameterValue(parameters, "tableName", String.class, null);
        String primaryKeyColumn = Convert.getParameterValue(parameters, "primaryKeyColumn", String.class, null);
        String[] columnNames = Convert.getParameterValue(parameters, "columnNames", String[].class, null);
        @SuppressWarnings("unchecked")
        ColumnConvertor<T>[] columnConvertors = Convert.getParameterValue(parameters, "columnConvertors", ColumnConvertor[].class, null); // This is NOT checked, but nothing can be done about it
        Properties properties = new Properties();
        for (Map.Entry<String, Object> entry : parameters.entrySet()) {
            if (entry.getValue() instanceof String)
                properties.setProperty(entry.getKey(), (String)entry.getValue());
        }
        DatabaseStorage<T> storage = new DatabaseStorage<T>(
                storedObjectsClass, dbConnUrl, properties, driverClass, tableName, primaryKeyColumn, columnNames, columnConvertors);
        return storage;
    }


    //****************** Data access methods ******************//

    /**
     * Returns the class of objects that the this storage works with.
     * @return the class of objects that the this storage works with
     */
    public Class<? extends T> getStoredObjectsClass() {
        return storedObjectsClass;
    }

    /**
     * Returns <tt>true</tt> if this storage contains no elements.
     * @return <tt>true</tt> if this storage contains no elements
     */
    public boolean isEmpty() {
	return size() == 0;
    }


    //****************** Storage methods implementation ******************//

    /**
     * Returns the number of elements in this storage.
     * @return the number of elements in this storage
     */
    @Override
    public synchronized int size() {
        try {
            sizeStatement = execute(sizeStatement, sizeSQL, null, null, false);
            ResultSet result = sizeStatement.getResultSet();
            try {
                if (!result.next())
                    throw new IllegalStateException("Size query returned no row - this should never happen!");
                return result.getInt(1);
            } finally {
                result.close();
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Cannot execute size query: " + e.getMessage(), e);
        } catch (BucketStorageException e) {
            throw new IllegalStateException("Cannot execute size query: " + e.getMessage(), e);
        }
    }

    @Override
    public synchronized IntAddress<T> store(T object) throws BucketStorageException {
        try {
            ResultSet generatedKeys;
            try {
                insertStatement = execute(insertStatement, insertSQL, null, object, true);
                generatedKeys = insertStatement.getGeneratedKeys();
                if (generatedKeys != null)
                    try {
                        if (generatedKeys.next() && generatedKeys.getMetaData().getColumnCount() > 0)
                            return new IntAddress<T>(this, generatedKeys.getInt(1));
                    } finally {
                        generatedKeys.close();
                    }
            } catch (SQLFeatureNotSupportedException ignore) { // Generated keys flag is not supported
            }

            // Generated keys failed, do full by-object select
            readByDataStatement = execute(readByDataStatement, readByDataSQL, null, object, false);
            generatedKeys = readByDataStatement.getResultSet();
            try {
                if (!generatedKeys.next())
                    throw new StorageFailureException("No generated column was found", null);
                return new IntAddress<T>(this, generatedKeys.getInt(1));
            } finally {
                generatedKeys.close();
            }
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }

    @Override
    public synchronized T read(int address) throws BucketStorageException {
        try {
            readStatement = execute(readStatement, readSQL, address, null, false);
            ResultSet result = readStatement.getResultSet();
            try {
                if (!result.next())
                    throw new InvalidAddressException("There is no object with address " + address);
                return toValue(result);
            } finally {
                result.close();
            }
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }

    @Override
    public synchronized void remove(int address) throws BucketStorageException, UnsupportedOperationException {
        try {
            deleteStatement = execute(deleteStatement, deleteSQL, address, null, false);
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }

    /**
     * Updates the object on address {@code address} with data from {@code object}.
     * Note that some storages may not support in-place update - the
     * {@link UnsupportedOperationException} is thrown when calling this method.
     * @param address the address of the object in the storage that is to be updated
     * @param object the new object data
     * @throws BucketStorageException if there was a problem storing the object
     * @throws UnsupportedOperationException if this operation is not supported by this storage
     */
    public synchronized void update(int address, T object) throws BucketStorageException, UnsupportedOperationException {
        try {
            updateStatement = execute(updateStatement, updateSQL, address, object, false);
        } catch (SQLException e) {
            throw new StorageFailureException(e);
        }
    }


    //****************** Default index implementation ******************//

    @Override
    public boolean add(T object) throws BucketStorageException {
        return store(object) != null;
    }

    @Override
    public IntStorageSearch<T> search() throws IllegalStateException {
        return search(null, null, null);
    }

    /**
     * Returns a name of a column that is compatible with the given comparator.
     * @param comparator the comparator for which to get column name
     * @return a column name or <tt>null</tt>
     */
    private int getComparatorCompatibleColumn(IndexComparator<?, ? super T> comparator) {
        if (comparator == null)
            return -1;
        for (int i = 0; i < columnConvertors.length; i++) {
            if (columnConvertors[i] instanceof SearchableColumnConvertor &&
                    ((SearchableColumnConvertor<?, T>)columnConvertors[i]).isColumnCompatible(comparator)) {
                return i;
            }
        }
        return -2;
    }

    @Override
    public <C> IntStorageSearch<T> search(IndexComparator<? super C, ? super T> comparator, C key) throws IllegalStateException {
        return search(comparator, Collections.singletonList(key));
    }

    @Override
    public <C> IntStorageSearch<T> search(IndexComparator<? super C, ? super T> comparator, Collection<? extends C> keys) throws IllegalStateException {
        return new DatabaseStorageSearch<C>(comparator, getComparatorCompatibleColumn(comparator), keys);
    }

    @SuppressWarnings("unchecked")
    @Override
    public <C> IntStorageSearch<T> search(IndexComparator<? super C, ? super T> comparator, C from, C to) throws IllegalStateException {
        return new DatabaseStorageSearch<C>(comparator, getComparatorCompatibleColumn(comparator), from, to);
    }

    /**
     * Encapsulates a {@link ResultSet} search on the database storage.
     * All objects that have the value of the given column between from and to are returned.
     * @param <C> the type the boundaries used by the search
     */
    private class DatabaseStorageSearch<C> extends AbstractSearch<C, T> implements IntStorageSearch<T> {
        /** Index of the column that contains the searched keys (use <tt>-2</tt> to do full scan, use <tt>-1</tt> to use primary key) */
        private final int columnIndex;
        /** Query result set that provides data for this search */
        private ResultSet resultSet;
        /** Statement that needs to be closed along with the result */
        private PreparedStatement resultSetStatement;

        /**
         * Creates a new instance of DatabaseStorageSearch.
         * The search uses SQL "where" clause to limit the returned data
         * to those that have values of column {@code columnName} set to given keys.
         *
         * @param comparator the comparator that is used to compare the keys
         * @param columnIndex the index of the column that contains the keys (use <tt>-2</tt> to do full scan, use <tt>-1</tt> to use primary key)
         * @param keys list of keys to search for
         * @throws IllegalStateException if there was an error executing the query
         */
        private DatabaseStorageSearch(IndexComparator<? super C, ? super T> comparator, int columnIndex, Collection<? extends C> keys) throws IllegalStateException {
            // Pass the comparator only if the database column is not provided (and thus the filtering must be done)
            super(columnIndex >= -1 ? null : comparator, keys);
            this.columnIndex = columnIndex;

            // Execute the query
            try {
                this.resultSet = executeQuery();
            } catch (SQLException e) {
                throw new IllegalStateException("Cannot search database: " + e.getMessage(), e);
            }
        }

        /**
         * Creates a new instance of DatabaseStorageSearch.
         * The search uses SQL "where" clause to limit the returned data
         * to those that have values of column {@code columnName} set to given keys.
         *
         * @param comparator the comparator that is used to compare the keys
         * @param columnIndex the index of the column that contains the keys (use <tt>-2</tt> to do full scan, use <tt>-1</tt> to use primary key)
         * @param fromKey the lower bound on the searched keys
         * @param toKey the upper bound on the searched keys
         * @throws IllegalStateException if there was an error executing the query
         */
        private DatabaseStorageSearch(IndexComparator<? super C, ? super T> comparator, int columnIndex, C fromKey, C toKey) throws IllegalStateException {
            // Pass the comparator only if the database column is not provided (and thus the filtering must be done)
            super(columnIndex >= -1 ? null : comparator, fromKey, toKey);
            this.columnIndex = columnIndex;

            // Execute the query
            try {
                this.resultSet = executeQuery();
            } catch (SQLException e) {
                throw new IllegalStateException("Cannot search database: " + e.getMessage(), e);
            }
        }

        /**
         * Executes the encapsulated SQL query and returns the resulting resultset.
         * @return the SQL query result set
         * @throws SQLException if there was a problem executing the query
         */
        private ResultSet executeQuery() throws SQLException {
            StringBuilder sql;
            Object[] parameters;
            if (columnIndex <= -2) { // Full scan search
                sql = new StringBuilder(selectSQL);
                parameters = null;
            } else { // Single-column search
                String columnName;
                if (columnIndex == -1) { // Primary key search (no conversion of keys)
                    columnName = primaryKeyColumn;
                    parameters = getKeys();
                } else { // Other column search - must be converted
                    columnName = columnNames[columnIndex];
                    parameters = new Object[getKeyCount()];
                    @SuppressWarnings("unchecked") // This is checked in the constructor call
                    SearchableColumnConvertor<? super C, T> columnConvertor = ((SearchableColumnConvertor<? super C, T>)columnConvertors[columnIndex]);
                    for (int i = 0; i < parameters.length; i++)
                        parameters[i] = columnConvertor.convertKeyToColumnValue(getKey(i));
                }
                if (isKeyBounds()) {
                    sql = new StringBuilder(selectSQL).append(" where ").append(columnName).append(" between ? and ?");
                } else {
                    sql = new StringBuilder(selectSQL);
                    sql.append(" where ").append(columnName).append(" in (");
                    for (int i = 0; i < parameters.length; i++)
                        sql.append(i == 0 ? "?" : ",?");
                    sql.append(')');
                }

            }
            resultSetStatement = prepareAndExecute(null, sql.toString(), false, parameters);
            return resultSetStatement.getResultSet();
        }

        @Override
        protected void finalize() throws Throwable {
            close();
            super.finalize();
        }

        @Override
        public AbstractSearch<C, T> clone() throws CloneNotSupportedException {
            try {
                DatabaseStorageSearch<C> ret = (DatabaseStorageSearch<C>)super.clone(); // This cast IS checked, because it is clonning
                ret.resultSet = ret.executeQuery();
                ret.resultSet.absolute(this.resultSet.getRow());
                return ret;
            } catch (SQLException e) {
                throw new CloneNotSupportedException(e.toString());
            }
        }

        @Override
        protected T readNext() throws BucketStorageException {
            try {
                if (!resultSet.next())
                    return null;
                return toValue(resultSet);
            } catch (SQLException e) {
                throw new StorageFailureException(e);
            }
        }

        @Override
        protected T readPrevious() throws BucketStorageException {
            try {
                if (!resultSet.previous())
                    return null;
                return toValue(resultSet);
            } catch (SQLException e) {
                throw new StorageFailureException(e);
            }
        }

        @Override
        public boolean skip(int count) throws IllegalStateException {
            // If there is a comparator defined, we must check keys
            if (getComparator() != null)
                return super.skip(count);

            // No comparator, we can seek faster
            try {
                if (count < 0 && resultSet.relative(count + 1)) // Skip backwards
                    return previous();
                else if (count > 0 && resultSet.relative(count - 1)) // Skip forward
                    return next();
                return true;
            } catch (SQLException e) {
                throw new IllegalStateException("Error skipping " + count + " objects from the underlying storage", e);
            }
        }

        @Override
        public IntAddress<T> getCurrentObjectAddress() throws IllegalStateException {
            return new IntAddress<T>(DatabaseStorage.this, getCurrentObjectIntAddress());
        }

        @Override
        public int getCurrentObjectIntAddress() throws IllegalStateException {
            try {
                return resultSet.getInt(1);
            } catch (SQLException e) {
                throw new IllegalStateException("There is no current object", e);
            }
        }

        @Override
        public void remove() throws IllegalStateException, BucketStorageException {
            DatabaseStorage.this.remove(getCurrentObjectIntAddress());
        }

        @Override
        public void close() {
            try {
                resultSet.close();
                resultSetStatement.close();
            } catch (SQLException ignore) {
            }
        }
    }

    //****************** Implementations of common column convertors ******************//

    /**
     * Column convertor that uses a database BLOB into which instances of {@code T} are
     * {@link BinarySerializator binary serialized/deserialized}.
     *
     * @param <T> the class of instances that are serialized into the database
     */
    public static class BinarySerializableColumnConvertor<T> implements ColumnConvertor<T> {
        /** class serial id for serialization */
        private static final long serialVersionUID = 1L;

        //****************** Attributes ******************//

        /** Class of instances serialized into the database */
        private final Class<? extends T> storedObjectsClass;
        /** Serializator that is used for storing/restoring the data into the database */
        private final BinarySerializator serializator;
        /** Flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage */
        private final boolean usedToRead;
        /** Flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage */
        private final boolean usedToWrite;


        //****************** Constructor ******************//

        /**
         * Creates a new instance of BinarySerializableColumnConvertor.
         *
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param serializator the serializator that is used for storing/restoring the data into the database
         * @param usedToRead a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage
         * @param usedToWrite a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage
         */
        public BinarySerializableColumnConvertor(Class<? extends T> storedObjectsClass, BinarySerializator serializator, boolean usedToRead, boolean usedToWrite) {
            this.storedObjectsClass = storedObjectsClass;
            this.serializator = serializator;
            this.usedToRead = usedToRead;
            this.usedToWrite = usedToWrite;
        }

        /**
         * Creates a new instance of BinarySerializableColumnConvertor.
         * Flags {@link #usedToRead usedToRead} and {@link #usedToWrite usedToWrite}
         * are both set to <tt>true</tt>.
         *
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param serializator the serializator that is used for storing/restoring the data into the database
         */
        public BinarySerializableColumnConvertor(Class<? extends T> storedObjectsClass, BinarySerializator serializator) {
            this(storedObjectsClass, serializator, true, true);
        }


        //****************** Implementation of ColumnConvertor interface ******************//

        @Override
        public Object convertToColumnValue(T instance) throws BucketStorageException {
            try {
                return serializator.write(instance, false).write();
            } catch (IOException e) {
                throw new StorageFailureException(e);
            }
        }

        @Override
        public boolean isConvertToColumnUsed() {
            return usedToWrite;
        }
        
        @Override
        public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
            if (column == null)
                return null;
            try {
                return serializator.readObject(new BufferInputStream((byte[])column), storedObjectsClass);
            } catch (IOException e) {
                throw new StorageFailureException(e);
            }
        }

        @Override
        public boolean isConvertFromColumnUsed() {
            return usedToRead;
        }
    }

    /**
     * Column convertor that uses a database String into which instances of {@code T} are
     * serialized using {@link LocalAbstractObject#write(java.io.OutputStream) write}
     * method and deserialized using {@link TextStreamFactory}.
     *
     * @param <T> the class of instances that are serialized into the database
     */
    public static class LocalAbstractObjectTextStreamColumnConvertor<T extends LocalAbstractObject> implements ColumnConvertor<T> {
        /** class serial id for serialization */
        private static final long serialVersionUID = 1L;

        //****************** Attributes ******************//

        /** Factory for reading objects from database */
        private final TextStreamFactory<? extends T> factory;
        /** Flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage */
        private final boolean usedToRead;
        /** Flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage */
        private final boolean usedToWrite;


        //****************** Constructor ******************//

        /**
         * Creates a new instance of LocalAbstractObjectTextStreamColumnConvertor.
         *
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param usedToRead a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage
         * @param usedToWrite a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage
         * @param additionalArguments additional arguments for the constructor
         */
        public LocalAbstractObjectTextStreamColumnConvertor(Class<? extends T> storedObjectsClass, boolean usedToRead, boolean usedToWrite, Object... additionalArguments) {
            this.factory = new LocalAbstractObject.TextStreamFactory<T>(storedObjectsClass, additionalArguments);
            this.usedToRead = usedToRead;
            this.usedToWrite = usedToWrite;
        }

        /**
         * Creates a new instance of LocalAbstractObjectTextStreamColumnConvertor.
         * Flags {@link #usedToRead usedToRead} and {@link #usedToWrite usedToWrite}
         * are both set to <tt>true</tt>.
         *
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         */
        public LocalAbstractObjectTextStreamColumnConvertor(Class<? extends T> storedObjectsClass) {
            this(storedObjectsClass, true, true);
        }


        //****************** Implementation of ColumnConvertor interface ******************//

        @Override
        public Object convertToColumnValue(LocalAbstractObject instance) throws BucketStorageException {
            try {
                ByteArrayOutputStream data = new ByteArrayOutputStream();
                instance.write(data);
                data.close();
                // Remove trailing newline
                String ret = data.toString();
                return ret.charAt(ret.length() - 1) == '\n' ? ret.substring(0, ret.length() - 1) : ret;
            } catch (IOException e) {
                throw new StorageFailureException(e);
            } catch (RuntimeException e) {
                throw new StorageFailureException(e);
            }
        }

        @Override
        public boolean isConvertToColumnUsed() {
            return usedToWrite;
        }

        @Override
        public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
            try {
                return factory.create((String)column);
            } catch (InvocationTargetException e) {
                throw new StorageFailureException(e.getCause());
            }
        }

        @Override
        public boolean isConvertFromColumnUsed() {
            return usedToRead;
        }
    }

    /**
     * Column convertor that uses a database String into which instances of
     * an {@link LocalAbstractObject} encapsulated in {@code T} are
     * serialized using {@link LocalAbstractObject#write(java.io.OutputStream) write}
     * method and deserialized using {@link TextStreamFactory}.
     *
     * Note that this convertor can be used only to writing.
     *
     * @param <T> the class of instances that are serialized into the database
     */
    public static class MetaObjectTextStreamColumnConvertor<T extends MetaObject> extends LocalAbstractObjectTextStreamColumnConvertor<T> {
        /** class serial id for serialization */
        private static final long serialVersionUID = 1L;

        //****************** Attributes ******************//

        /** Name of the {@link LocalAbstractObject} encapsulated in the {@link MetaObject} */
        private final String encapsulatedObjectName;


        //****************** Constructor ******************//

        /**
         * Creates a new instance of MetaObjectTextStreamColumnConvertor.
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param encapsulatedObjectName the name of the {@link LocalAbstractObject} encapsulated in the {@link MetaObject}
         */
        public MetaObjectTextStreamColumnConvertor(Class<? extends T> storedObjectsClass, String encapsulatedObjectName) {
            super(storedObjectsClass, false, true);
            this.encapsulatedObjectName = encapsulatedObjectName;
        }


        //****************** Implementation of ColumnConvertor interface ******************//

        @Override
        public Object convertToColumnValue(T instance) throws BucketStorageException {
            return super.convertToColumnValue(instance.getObject(encapsulatedObjectName));
        }

        @Override
        public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
            throw new UnsupportedOperationException("MetaObjectTextStreamColumnConvertor should never be used when retrieving object from storage");
        }

    }

    /**
     * Column convertor that uses a bean property to decompose/restore
     * a given object to/from a database storage. Typically, a bean is decomposed
     * into several primitive columns in the database by using property getter method
     * and the restored by using setter methods.
     *
     * @param <T> the class of instances that are serialized into the database
     */
    public static class BeanPropertyColumnConvertor<T> implements SearchableColumnConvertor<Object, T> {
        /** class serial id for serialization */
        private static final long serialVersionUID = 1L;

        //****************** Attributes ******************//

        /** Class of instances serialized into the database */
        private final Class<? extends T> storedObjectsClass;
        /** Method used to read the value of the object's property */
        private final Method getterMethod;
        /** Method used to write the value of the object's property */
        private final Method setterMethod;


        //****************** Constructor ******************//

        /**
         * Creates a new instance of BeanPropertyColumnConvertor.
         *
         * @param propertyName the name of the property of the {@code storedObjectsClass} to use
         * @param storedObjectsClass the class of instances that are serialized by this column convertor
         * @param usedToRead a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage
         * @param usedToWrite a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage
         * @throws IllegalArgumentException if there was no property of the given name in {@code storedObjectsClass}
         */
        public BeanPropertyColumnConvertor(String propertyName, Class<? extends T> storedObjectsClass, boolean usedToRead, boolean usedToWrite) throws IllegalArgumentException {
            this.storedObjectsClass = storedObjectsClass;
            PropertyDescriptor propertyDescriptor = null;
            try {
                BeanInfo beanInfo = Introspector.getBeanInfo(storedObjectsClass);
                for (PropertyDescriptor pd : beanInfo.getPropertyDescriptors()) {
                    if (propertyName.equals(pd.getName())) {
                        propertyDescriptor = pd;
                        break;
                    }
                }
            } catch (IntrospectionException e) {
                throw new IllegalArgumentException("Property '" + propertyName + "' on " + storedObjectsClass + " cannot be used", e);
            }
            if (propertyDescriptor == null)
                throw new IllegalArgumentException("Property '" + propertyName + "' on " + storedObjectsClass + " was not found");

            if (usedToRead) {
                setterMethod = propertyDescriptor.getWriteMethod();
                if (setterMethod == null)
                    throw new IllegalArgumentException("Property '" + propertyName + "' on " + storedObjectsClass + " cannot be used when reading the object from the database");
            } else {
                setterMethod = null;
            }

            if (usedToWrite) {
                getterMethod = propertyDescriptor.getReadMethod();
                if (getterMethod == null)
                    throw new IllegalArgumentException("Property '" + propertyName + "' on " + storedObjectsClass + " cannot be used when storing the object to the database");
            } else {
                getterMethod = null;
            }
        }


        //****************** Implementation of ColumnConvertor interface ******************//

        @Override
        public Object convertToColumnValue(T instance) throws BucketStorageException {
            try {
                return getterMethod.invoke(instance);
            } catch (InvocationTargetException e) {
                throw new StorageFailureException(e.getCause());
            } catch (Exception e) {
                throw new StorageFailureException(e);
            }
        }

        @Override
        public boolean isConvertToColumnUsed() {
            return getterMethod != null;
        }

        @Override
        public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
            try {
                // Create a new bean instance if it does not exist yet
                if (value == null)
                    value = storedObjectsClass.newInstance();
                setterMethod.invoke(value, column);
                return value;
            } catch (InvocationTargetException e) {
                throw new StorageFailureException(e.getCause());
            } catch (Exception e) {
                throw new StorageFailureException(e);
            }
        }

        @Override
        public boolean isConvertFromColumnUsed() {
            return setterMethod != null;
        }

        @Override
        public boolean isColumnCompatible(IndexComparator<?, ? super T> indexComparator) {
            return indexComparator != null &&
                    indexComparator.equals(LocalAbstractObjectOrder.trivialObjectComparator) &&
                    Comparable.class.isAssignableFrom(setterMethod.getReturnType());
        }

        @Override
        public Object convertKeyToColumnValue(Object key) {
            return key;
        }
    }

    /**
     * Column convertor that stores/restores a {@link LocalAbstractObject#getLocatorURI() locator URI}
     * of {@link LocalAbstractObject}s stored in the database. Note that the associated column must
     * be {@link String}-compatible. When restoring an object, its key is set only if it has no key yet.
     */
    public static final ColumnConvertor<LocalAbstractObject> locatorColumnConvertor = new SearchableColumnConvertor<String, LocalAbstractObject>() {
        private static final long serialVersionUID = 1L;

        @Override
        public Object convertToColumnValue(LocalAbstractObject instance) throws BucketStorageException {
            return instance.getLocatorURI();
        }

        @Override
        public boolean isConvertFromColumnUsed() {
            return true;
        }

        @Override
        public LocalAbstractObject convertFromColumnValue(LocalAbstractObject value, Object column) throws BucketStorageException {
            if (value != null && column != null && value.getObjectKey() == null)
                value.setObjectKey(new AbstractObjectKey(column.toString()));
            return value;
        }

        @Override
        public boolean isConvertToColumnUsed() {
            return true;
        }

        @Override
        public boolean isColumnCompatible(IndexComparator<?, ? super LocalAbstractObject> indexComparator) {
            return indexComparator != null && indexComparator.equals(LocalAbstractObjectOrder.locatorToLocalObjectComparator);
        }

        @Override
        public Object convertKeyToColumnValue(String key) {
            return key;
        }
    };

    /**
     * Returns a column convertor that stores/restores a {@link LocalAbstractObject#getLocatorURI() locator URI}
     * of {@link LocalAbstractObject}s stored in the database. In fact, this method
     * just returns the generic-typed {@link #locatorColumnConvertor}.
     * @param <T> the class of object for which to get the locator column convertor
     * @param objectClass the class of object for which to get the locator column convertor
     * @return a column convertor
     */
    @SuppressWarnings("unchecked")
    public static <T extends LocalAbstractObject> ColumnConvertor<T> getLocatorColumnConvertor(Class<T> objectClass) {
        return (ColumnConvertor)locatorColumnConvertor;
    }

    /**
     * Column convertor that stores/restores instances supported directly by the database.
     * For example, numbers can be accessed as {@link Integer}s or {@link Double}s, BLOBs as byte[] arrays, etc.
     * Note that this convertor states a compatibility with {@link LocalAbstractObjectOrder#trivialObjectComparator}
     * since practically all database types are inherently {@link Comparable}.
     */
    public static final ColumnConvertor<Object> trivialColumnConvertor = new SearchableColumnConvertor<Object, Object>() {
        private static final long serialVersionUID = 1L;

        @Override
        public Object convertToColumnValue(Object instance) throws BucketStorageException {
            return instance;
        }

        @Override
        public boolean isConvertFromColumnUsed() {
            return true;
        }

        @Override
        public Object convertFromColumnValue(Object value, Object column) throws BucketStorageException {
            return column;
        }

        @Override
        public boolean isConvertToColumnUsed() {
            return true;
        }

        @Override
        public boolean isColumnCompatible(IndexComparator<?, Object> indexComparator) {
            return indexComparator != null && indexComparator.equals(LocalAbstractObjectOrder.trivialObjectComparator);
        }

        @Override
        public Object convertKeyToColumnValue(Object key) {
            return key;
        }
    };

    /**
     * Wraps a column convertor while changing its read/write capabilities.
     *
     * @param <T> the column convertor class
     * @param convertor the convertor to wrap
     * @param usedToRead a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is retrieved from the storage
     * @param usedToWrite a flag whether this column convertor is used (<tt>true</tt>) or should be skipped (<tt>false</tt>) when the object is stored into the storage
     * @param skipReadIfNotNull a flag whether this column convertor is used to convert the value from database even if there was a value already provided (<tt>true</tt>) or not (<tt>false</tt>)
     * @return a wrapped convertor with changed read/write/skip flags
     * @throws IllegalArgumentException if a read/write flag was set for a convertor that does not support reading/writing
     */
    public static <T> ColumnConvertor<T> wrapConvertor(final ColumnConvertor<T> convertor, final boolean usedToRead, final boolean usedToWrite, final boolean skipReadIfNotNull) throws IllegalArgumentException {
        if (usedToRead && !convertor.isConvertFromColumnUsed())
            throw new IllegalArgumentException("Cannot set used-to-read flag on convertor that does not support reading");
        if (usedToWrite && !convertor.isConvertToColumnUsed())
            throw new IllegalArgumentException("Cannot set used-to-write flag on convertor that does not support writing");
        if (convertor instanceof SearchableColumnConvertor) {
            @SuppressWarnings("unchecked") // This is ok, since this wraps an existing searchable column convertor
            final SearchableColumnConvertor<Object, T> searchableConvertor = (SearchableColumnConvertor<Object, T>)convertor;
            return new SearchableColumnConvertor<Object, T>() {
                /** class serial id for serialization */
                private static final long serialVersionUID = 1L;
                @Override
                public Object convertToColumnValue(T instance) throws BucketStorageException {
                    return searchableConvertor.convertToColumnValue(instance);
                }
                @Override
                public boolean isConvertToColumnUsed() {
                    return usedToWrite;
                }
                @Override
                public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
                    if (skipReadIfNotNull && value != null)
                        return value;
                    return searchableConvertor.convertFromColumnValue(value, column);
                }
                @Override
                public boolean isConvertFromColumnUsed() {
                    return usedToRead;
                }
                @Override
                public boolean isColumnCompatible(IndexComparator<?, ? super T> indexComparator) {
                    return searchableConvertor.isColumnCompatible(indexComparator);
                }
                @Override
                public Object convertKeyToColumnValue(Object key) {
                    return searchableConvertor.convertKeyToColumnValue(key);
                }
            };
        } else {
            return new ColumnConvertor<T>() {
                /** class serial id for serialization */
                private static final long serialVersionUID = 1L;
                @Override
                public Object convertToColumnValue(T instance) throws BucketStorageException {
                    return convertor.convertToColumnValue(instance);
                }
                @Override
                public boolean isConvertToColumnUsed() {
                    return usedToWrite;
                }
                @Override
                public T convertFromColumnValue(T value, Object column) throws BucketStorageException {
                    if (skipReadIfNotNull && value != null)
                        return value;
                    return convertor.convertFromColumnValue(value, column);
                }
                @Override
                public boolean isConvertFromColumnUsed() {
                    return usedToRead;
                }
            };
        }
    }
}
